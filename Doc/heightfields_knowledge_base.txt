## Heightfields Knowledge Base - 目录

本知识库涵盖 Houdini 地形系统（Heightfields & Terrain）的完整文档。
包含地形创建、侵蚀、遮罩、层管理、VEX脚本、散点、浅水模拟等主题。

============================================================
# 来源: index.txt
============================================================

## Heightfields and terrains
How to use Houdini's heightfield tools to generate realistic terrains.

## Heightfields and terrains - Overview
Houdini provides a wide range of nodes and tools for generating realistic terrains through heightfields. A heightfield doesn't consist of traditional geometry like vertices and polygons. You can think of a heightfield as 2-dimensional grid with cells. The intersecting points of that grid contain the terrain's height information.

This approach lets you combine and stack different types of terrain, e.g. a bedrock with a layer of soil on top. These elements are called height layers, while the base layer - here it's the bedrock - is always named `height`. Layers play an important role with heightfields in general and it's all about stacking and manipulating layers to achieve the results you're looking for. The advantage with this technique is that you keep full artistic control, because you can turn on and off layers temporarily, work on each layer individually or add new layers at any point of your network.

Most terrain nodes take a second input that can contain a mask layer to control, which parts of the terrain the node will modify. The default mask layer is named `mask`. As with height layers, it's possible to have multiple, differently named mask layers in a geometry stream. Then you can specify which mask layer you want to use, e.g. for applying erosion or terraces.

The Houdini viewport is capable of visualizing the 2D `height` field as a 3D surface, and the `mask` field as a red tint on the surface. Heightfields aren't limited to huge terrains, but you can also create smaller landscapes, riverbeds, seabeds, deserts, and many other geological structures. It's also possible to paint your own map and use it as a basis for a complex and highly-detailed terrain. The perhaps most realistic approach is to load a displacement map from a real landscape and turn it into a heightfield.

[NOTE]
    A special form of heightfield is the Shallow Water Solver that lets you quickly flood large areas or make water run over rocks and cracks.

## Heightfields and terrains - Limitations
As mentioned before, heightfields are flat 2D grids and all height information is stored in the grid's points. For this reason it's not possible to work on a terrain's vertical areas. A good example are the vertical parts you get from a HeightField Project SOP. This nodes takes regular geometry and projects it onto the 2D grid. Masks can also create very similar effects. The image below shows a sphere that is projected onto an empty heightfield. The vertical parts are just stretched along the Y axis.

If you want to add detail to the vertical parts, you can erode the terrain or convert the heightfield into actual geometry. Another possibility is to scatter objects over those areas to create structures.

Of course, Houdini's Karma CPU and Karma XPU render engines support heightfields. Anyway, before you can render a heightfield you should convert it into polygons. This step is not absolutely necessary, because Houdini will convert the terrain automatically when you import it to Solaris. However, you have more control over the resulting geometry with manual conversion, for example if you want to you bake colors and layers to the terrain.

## Heightfields and terrains - Noise types
Different noise types are one of the centerpieces in conjunction with heightfields and you can find them everywhere: terrain creation, masking, distortion, patterns, etc. Especially the various noise types on the HeightField Noise SOP are perfectly suited to quickly change the characteristics of a terrain. You can create landscapes with smooth hills or mountains with sharp ridges and steep slopes.

On the first look, some noise types like Chebyshev Cellular F2-F1 might create strange patterns. With appropriate distortion and stacked noise types you can create highly-detailed terrains. Then you apply erosion to the mountains to get a realistic look.

The noise settings of different nodes also share several common parameters. The most important are probably Amplitude and Element Size. Amplitude defines the maximum height of the terrain. Element Size, however, refers to the noise pattern. In terms of heightfields you add more spikes and irregularities with small values, while higher settings create a smoother surface.

The ratio between Amplitude and Element Size is also relevant. 

* When Element Size is small, you normally decrease Amplitude. 
* With large Element Size, the terrain becomes flatter and you'll most probably increase Amplitude.

The image below shows that you can achieve different types of terrain just by varying Element Size and Amplitude.

## Heightfields and terrains - Generating a height field from scratch
To create a basic heightfield, you need only a couple of nodes. The nodes' parameters let you precisely shape the landscape and you can create distant hills with a reduced level of detail or high-resolution ground object for scattering. You normally only have to alter very few parameters to get a completely different look.

Heightfields are created through geometry SOP nodes, so everything starts on Houdini's obj level, where you press Tab to open the tab menu. From there, create a Geometry OBJ that will serve as container for your landscape. Double-click the node to dive inside.

### Heightfield base

* Lay down a HeightField SOP. This node generates a large, flat plane in ZX direction that is centered to the scene's origin.

The most important parameters are Size and Grid Spacing. The first parameters determines the terrain's global scale.

The default size is `1000` by `1000` meters - that's one square kilometer. Grid Spacing, however, defines the heightfield's resolution. You can also think of this value as a voxel's size. With the standard value of `2`, the distance between two grid points is two meters. This results in 500 by 500 voxels for a base heightfield.

You can also change Division Mode to By Axis and directly set the number of grid points.

### Heightfield noise

A HeightField node followed by a HeightField Noise SOP is the primary way to start with some random terrain. From the tab menu, add a HeightField Noise SOP and connect its first input with the output of the HeightField SOP. What you can see now is a rocky terrain with several hills. If you need more detail, you can decrease the aforementioned Grid Spacing parameter on the HeightField SOP. On the noise node, you change the look of the landscape.

[NOTE]
    The noise parameters, described below, are an important part of Houdini's heightfield technology in general. You'll therefore see most of the settings in other nodes and their mode of operation is always the same.

With Amplitude you change the maximum height of the terrain. Note that the value is *not* given in meters and the standard value of `500` doesn't create hills with an appropriate height. Amplitude is a scale factor that's applied to each grid point's displacement value. When Center Noise is turned on, the factor will be applied in both positive and negative Y direction (assuming that the heightfield is oriented along the XZ plane).

Element Size determines the size of the noise pattern. With smaller values you'll get a more noisy surface with lots of spikes. Higher settings, however, create a smoother surface with less detail. Element Size is the inverse of the noise's frequency.

The Scale parameters let you stretch the noise along its orientation: in most cases this is probably X and Z. The height axis, however isn't considered, because height is controlled through Amplitude.

It's also interesting to experiment with different Combine Mode settings. Maximum, for example, clips all values below 0 and creates a sea level with islands and coast lines. Minimum, on the other hand, can create eroded, canyon-like structures.

The Noise Settings section provides the Roughness parameter. With higher settings you create more micro-spikes and this results in a more noisy surface. You should change Roughness in small steps of `0.05`, because it's very sensitive.

There also many different Noise Types available. The Perlin, sparse and simplex types add detail to the terrain. The cellular types and Alligator, however, are perfectly suited for defining a terrain's main structure. Then you refine those with sparse noise and/or distortion. If you need more detail and finer structures on your terrain, plase consider increasing the Lacunarity value.

## Heightfields and terrains - Heightfield mask
A mask restricts an effect to a certain area. In conjunction with heightfields you can define, where the terrain should appear, while areas outside the mask will remain flat. When you press Tab to open the tab menu and enter `hfmask`, you'll see a long list of nodes for the creation and manipulation of masks. To illustrate the basic concept, lets start with a noise mask.

[TIP]
    For more information on masks, please read the HeightField masking page.

If you've already created a basic heightfield, you can proceed with the existing network. Scale and look of your heightfield don't matter. Here's a preview of the network you're going to create.

# From the tab menu, put down a HeightField Mask Noise SOP.
# You must place the new node between the already existing HeightField SOP and HeightField Noise SOP nodes to see an effect. Connect the mask node's

    * first input with the output of the heightfield
    * output with the second input of the heightfield noise.

# When you look at the mask node's parameters, you'll recognize the same parameters as with the HeightField Noise SOP: Amplitude, Element Size, and the Noise Settings section. Play with the parameters to achieve different looks.  Amplitude, by the way, acts like a like a multiplier for the height values.

To control the mask's actual look, turn on the mask node's blue Display/Render flag. Now you'll see a red and white pattern, and mountains are only created in the red areas.

## Heightfields and terrains - Tips and notes
* The Terrain desktop has a specialized shelf set, a radial menu, and its own pane layout designed for your work with terrains.

* You can take advantage of the Tab menu's smart completion when type `height` or just `hf` instead of `height field` when searching for appropriate nodes. For example, you can type `hfnoise` to get a list of all available heightfield noise nodes.

* Heightfields and masks are regular Houdini volumes and you can use any geometry (SOP) node that works with volumes to edit heightfields and masks.

@subtopics

## Heightfields and terrains - Creation
::[creation]
::[maps]
::[hills]
::[layers]
::[terracing] 
::[distortion]
::[painting]
::[projection]
::[patching]
::[patterns]
::[resampling]
::[workflows]

## Heightfields and terrains - Scattering
::[scattersop]
::[scatterptremove]
::[scatterattribs]
::[scattersolaris]

## Heightfields and terrains - Masking
::[masking]
::[lightmask]

## Heightfields and terrains - Natural effects
::[erosion]
::[slump]
::[flowfields]

## Heightfields and terrains - VEX
::[vexsnippets]
::[sandtransport]
::[mandelbrot]

## Heightfields and terrains - Texturing
::[texturebasics]
::[texturelayers]

## Heightfields and terrains - Shallow Water Solver
::[shallowintro]
::[shallowfields]
::[shallowtrouble]
::[shallowoutput]

============================================================
# 来源: creation.txt
============================================================

## Terrain creation
Fundamental workflows with Houdini's heightfields.

When you look at the examples of this guide, you'll notice that all workflow steps are applied to a high-resolution heightfield. This is actually just to give an instant view on the results and to see how certain nodes affect the terrain. In most cases, however, you'll start with a low-resolution heightfield. Then you add details and upsample the terrain. You create more details, do another upsampling path, and so on, until you've reached the final level of detail.

Nevertheless it's totally up to you whether you want to resample the terrain to increase resolution or work directly on a high-resolution heightfield from the very beginning. What you should do in any case is to reapply the detailing process with each step. This means that you can erode your terrain multiple times and refine the intermediate result with distortion.

A typical workflow involves several steps that fulfill certain "roles" to shape your terrain.

## Terrain creation - Massing
Massing involves blocking out the large-scale structure of the terrain in three dimensions. For example, in a mountainous terrain, how much space the mountains will occupy, the shape of the space they enclose, where the mountains are higher and lower, etc.

In heightfields, this means creating a basic, low-resolution field that has the general characteristics of the final terrain. The surfaces can be smooth or blocky at this stage. You'll add noise later. You outline the basic shape by 

* painting height values,
* projecting geometry,
* mapping image maps

directly into the heightfield.

## Terrain creation - Seeding
Seeding is the process of adding small disturbances to smooth surfaces to make them more natural. The less smooth the surfaces, the more realistic erosion will be later. Simply adding overall noise to the field alone, or projecting large-scale geometry alone, often does not create enough "obstacles" (features that water and soil must move around) to create interesting erosion. Seeding is about adding those obstacles. You can add detail to the terrain with

* noise
* distortion.

It's also possible to combine multiple noise layers to achieve realistic and feature-rich landscapes.

[TIP]
    One useful trick is to create a 3D model of a large field of random jagged rocky shapes (for example, using the Mountain SOP), then painting a mask on your heightfield (with falloff) and only projecting the rocky geometry into the masked area. Then add a HeightField Distort by Layer SOP or a HeightField Distort by Noise on top of that.

## Terrain creation - Lobing
Mountain formations are often broken into smaller sections, which can be thought of as lobes. Lobing is the process of taking a low resolution heightfield and using the Heightfield Erode SOP to cut a mountain into smaller sections.

The HieghtField Erode SOP was rewritten from scratch in Houdini 21 to create better, more realistic results with lesser, bur more intuitive parameters.

## Terrain creation - Remapping
Remapping involves repeating the massing/seeding/lobing steps multiple times to create different levels (for example foothills, low mountains, and high mountains).

The trick is to build your terrain in “elevation passes”. After the previous Heightfield Erode SOP, add a Heightfield Remap SOP and remap the elevation, compressing the field vertically. Then repeat the massing/seeding/lobing step over top of the previous now-compressed contents.

## Terrain creation - Upsampling
After finishing the lobing step you need to upsample the heightfield to a higher resolution. This will add more detail to the erosion.

Use the Heightfield Resample SOP to double the field's resolution. You will probably want to iterate this process, so do not resample too high at first!

## Terrain creation - Shaping
This step involves adding geologic features using the Heightfield Terrace SOP and Heightfield Clip SOP.

With masks, you can clip to top off mountains, and add terraces to certain areas to create more interesting variations for the erosion process.

## Terrain creation - Re-seeding
Re-seeding repeats the earlier seeding operation(s) at a higher resolution. The idea is to add more obstacles that will force erosion to change direction.

## Terrain creation - Erosion
Now use the full power of Heightfield Erode SOP to start getting the look you want. In fact, there are no "right" or "wrong" settings. All that matters is that the result looks interesting and natural. You will probably want iterate on this step a few times. You can also combine multiple erode nodes to create structures of different size.

## Terrain creation - Final
Once you have the terrain you want, you can move on to shading the terrain and scattering rocks and trees. The Heightfield Quickshade SOP gives you a simple material setup on your terrain quickly. The Heightfield Scatter SOP lets you scatter points for instancing across the terrain. You can 

* control the distribution of the scatter points with masks
* do a hierarchical scatter that prevents overlap of different scales
* add variant attributes to the points so, for example, they are instanced with different tree types or rock shapes.

============================================================
# 来源: distortion.txt
============================================================

## Distortion
Shape your terrains and make them look natural.

Houdini's distortion methods for heightfields let you add complex patterns to a terrain. This way you can mimic geological formations like lava fields, fluvatile sediments or dried-out plains, but also different types of eroded structures and abstract landscapes. Distortion is a very effective means to enhance and randomize the look of a terrain, but also for adding variation or detail.

Basically you differentiate between four fundamental distortion methods: warping, noise, layer-based distortion and pattern distortion.

[NOTE]
    All explanations and examples use a very basic terrain, consisting of a HeightField SOP and a HeightField Noise SOP to get some mountains and rocky structures. To get enough detail, set the heightfield node's Grid Spacing to `1`.

    For more information on how to work with this fundamental setup, please read the Generating a height field from scratch introduction.

## Distortion - Lattice Warp
Warping is part of the HeightField Noise SOP and you can find parameters for two fundamental methods in the Distortion section. Let's start with Lattice Warp. To get a better impression of how Lattice Warp changes the look of your terrain, set Amplitude to `100`. 

* Turn on Enable Lattice Warp. The effect on the terrain is very subtle and hardly visible.
* Turn off Accumulate Lattice Warp.
* Increase Lattice Warp to `2`.
* When you change Freq to `6`, you get crater-like surface structures.

Lattice warp adds a swirly look to the terrain and this effect becomes very obvious when you turn on Accumulate Lattice Warp. Now you can see a folded and kneaded terrain. When you decrease Freq, e.g. to `0.6`, the surface starts to look natural again and reminds of a landscape that was formed by water.

## Distortion - Gradient Warp
The Gradient Warp function widens the peaks and valleys of the noise and you can get completely different looks with positive and negative values. As with lattice warp, the gradient method strongly depends on the Accumulate Gradient Warp option. This function emphasizes the distortion effect and creates distinctive patterns. 

To see the effect of the settings, described below, turn off Enable Lattice Warp and reset Amplitude and Element Size to `500` each.

* With negative values you get a terrain with sharp crests. Try a value of `-0.1` to get the result shown in the image comparison below.
* When you enter a positive value around `0.2`, you get landscapes with rounded, almost pillow-shaped structures.
* Of course it's possible to combine both distortion methods and create hybrid heightfields.

## Distortion - Noise-based distortion
This type of distortion is available with the HeightField Distort by Noise SOP. The node provides a Noise Type dropdown menu with two methods: Curl and Simplex. The parameters for controlling the noise are identical for both types.

When you work with the node's noise types, consider the ratio between Amplitude and Element Size. High Amplitude values create lots of noise and spikes. To "stretch" the noise pattern and get usable patterns, increase Element Size. Another parameter you can use to flatten extreme spikes and reduce the amount of small details is Roughness. Another interesting parameter is Substeps for balancing extreme differences in the noise function.

* Curl is the node's default noise type to distort your heightfield. You can use this method to create "flowing"´structures, e.g. for riverbeds, glaciers, solidified lava fields or even organic effects. The noise also adds a terracing effect to the mountains' cliffs.
* Simplex is a noise type similar to Perlin noise, but creates smoother results. With Simplex it's also possible to achieve a moderate terracing effect and "flowing" structures.

In conjunction with the HeightField Noise SOP's Worley F1 Noise Type, you can create realistic mountain ranges with sharp crests.

## Distortion - Layer-based distortion
The HeightField Distort by Layer SOP.

* Layers defines the layer(s) you want to distort. Usually you want to distort `height` or `mask` or both.
* Control Layer expects a scalar or vector field. This can be the same or another heightfield, but also any other volumetric field.
* You can also use a Scale Field to drive the node's Displacement Scale.

You can connect a mask or even another heightfield network to the second input and a layer to Control Layer. However, the results are hard to predict, because the parameter combinations are nearly endless. In many cases you need rather high Displace Scale values to get a visible effect. Substeps also have a strong impact on the terrain's look.

[TIP]
    To get usable results you should consider adding erosion. A terminating HeightField Distort by Noise SOP (see above) will also help to achieve a realistic look as shown in the image below.

## Distortion - Pattern distortion
Another method to create interesting shapes and perhaps more abstract terrains, is pattern-based distortion. When you use the HeightField Pattern SOP, it's a good idea to start with a plain HeightField SOP without noise or any other distortion/elevation. Then connect the pattern node's first input with the output of the base grid and you're good to go.

The node provides a Pattern dropdown menu with six entries you can choose from. The default is Start, but the most versatile and customizable pattern is Ramp, because here you can define a custom curve. The image shows a distorted ramp pattern combined with a HeightField Noise SOP. Erosion and noise distortion give the terrain its final look. 

To get the terrain's base wave pattern follow the steps below.

# On the Heightfield Pattern SOP, choose Ramp and you will see a saw tooth pattern.
# On the Pattern > Position section, go to Remap Remapping and click the  Presets button. From the menu, choose Hill to create rounded stripes. This pattern is also suited for dunes.
# On the same section, set Size to `200` to decrease the number of waves.
# The bands are also very high. Decrease Scale to `20`.
# Go to the Distortion section and turn on Distort Pattern. The pattern is now slightly displaced.
# Now play with the Amplitude and Element Size parameters to add a curly noise pattern to the stripes. For the image below, the values are `600` and `500`.
# The terrain is now extremely distorted. To fix this, decrease Roughness to `0.2`. This parameter is responsible for the noise's coarseness and higher values add more high-frequency spikes.

You can also try different presets from Ramp Remapping or define a custom curve. Another interesting approach is to set Pattern > Position > Mode to Concentric. This mode creates a very organic pattern with a SciFi touch. Also consider changing Center to shift the "eye" of the pattern.

## Distortion - Mask distortion
The distortion methods, describes above, also work in conjunction with masks. For example, the HeightField Mask Noise SOP is just a regular HeightField Noise SOP with the Noise Layer parameter set to `mask`. You can still turn on the Lattice Warp and Gradient Warp methods and apply them to a mask.

This also applies to the HeightField Distort by Noise and HeightField Distort by Layer SOPs. Below you can see various distorted masks in a side-by-side comparison.

============================================================
# 来源: erosion.txt
============================================================

## Erosion
Turn mountains into dust.

Erosion is one of the most important nodes when it comes to terrain creation. In nature, terrains and landscapes are shaped by erosion. Erosion is caused by water, ice, wind, glaciers, but also heat and cold. Erosion shapes landscapes over time by removing material from the Earth's surface. The material breaks, crumbles, and is ground into increasingly finer material. This process results in fine sediments such as sand, silt or clay. Erosion brings different terrains together and it's the connecting element that combines patches, terraces and other features to create a believable and naturally-looking terrain.

In Houdini, you differentiate between two fundamental types: Water-based erosion and thermal erosion. The first type is typically labelled as "hydro" from the Greek word "hydros" for water. Thermal erosion is caused by differences in temperature and the term originates from the Greek word "thermos" for warm.

To simulate this process, you typically use the Heightfield Erode SOP. In Houdini 21, the node was entirely rewritten. It's now faster and easier to use. The parameter names are also more intuitive and describe natural phenomena like Erosion Rate, Flow Force or Weathering Force.

There are many examples and use cases throughout this guide that illustrate what the HeightField Erode SOP can do.

## Erosion - Basic usage
Again, you can start with the basic heightfield setup consisting of a HeightField SOP and a HeightField Noise. To simulate erosion, lay down a HeightField Erode SOP and connect its first input with the output of the noise node. When you turn on the erode node's blue Display/Render flag, you'll see two main features: erosion channels and smooth `sediment` areas. In fact there are also `debris`, `flow` and `flowdir` layers. The channels are not a separate layer, but the result of the erosion process.

With a Heightfield Visualize SOP, you can make the various layers visible. There, you have nine slots for various layers. Below you can see the `debris`, `sediment` and `flow` layers.

Erosion is a time-depending process and this means that you can change the look of the terrain with a simulation. The erode node's Freeze at Frame defines for how many frames the simulation should run. If you don't like the result, you can start again with Reset Simulation. You can also turn off Freeze at Frame if you want to watch/render the erosion process or create an animated flipbook.

The Erosion Feature Size determines the scale of the "channels". Smaller values create more detail and finer structures, but the quality of the erosion features also depends on the heightfield's resolution. Below a value of `3` or `2` you normally won't see any changes. The new erosion algorithm creates the typical look of the channels with a branched and "feathered" structure. The image below shows the complex pattern you can achieve with the new erosion model.

Spread Iterations controls the amount of sediment. With higher settings, the smooth areas become bigger, because more and more material will fill the deeper areas.

The parameters of the Hydro section simulate the flow of water and the amount of material that is being removed from the terrain. The Hydro parameters have stronger impact on the terrain's shape as the Thermal parameters. You can play with the various settings and there's no global rule for wrong or right values.

[TIP]
    Terrains often look better with a slight amount of distortion - even when they're eroded. As always, this depends on your scene and if you want to preserve the structures, you can terminate your network with erosion.

With default settings, the HeightField Erode SOP tends to remove large amounts of material. To restrict the amount of rock being entrained, you can decrease Flow Force. If you want to simulate different types of rock with different hardness, you can use a mask. The entire range of erosion parameters accepts masks. Another parameter that strongly affects the terrain's look is Spread Iterations. With high values, the eroded material is transported for longer distances and tends to fill valleys and level the terrain.

With smaller values for Flow Force and Spread Iterations you'll be able to maintain more terrain structures like terraces. The left image of the comparison below shows terraces with the erode node's default settings. The right image uses a Flow Force value of `0.3` and Spread Iterations is set to `25`.

## Erosion - Erosion stacking
A typical workflow with erosion is stacking. This means that you don't apply just one HeightField Erode SOP, but you do multiple iterations with different nodes. You apply masks to identify certain areas, you change parameters like Erosion Feature Size or Flow Force, and you distort the results. This way it's possible to create very realistic terrains with lots of features.

The workflow is straightforward. When you start with the first erosion node, you typically create the larger features, for example with an Erosion Feature Size of `20` or more. If you want to erode more material, you can also increase the node's Freeze at Frame parameter. The default value is `5`. Once you've found working settings, you don't have to store the current state. Instead, you connect the output of the first erosion node to another downstream erosion operator. The new node will take the current state, for example from frame 10, and uses it as the basis for the next erosion pass. This way you can create erosion cascades and each pass adds more detail the underlying structures.

You can also add HeightField Distort by Noise SOPs between the erosion nodes to get more variance and a rougher look:

HeightField -> HeightField Noise -> Erode -> Distort > Erode -> Distort -> Erode -> Distort...

The advantage with this setup is that it's fully procedural. You can change any parameter at any point in the network without having to update the entire node chain. You also normally don't have to resample the terrain between the individual erosion passes.

============================================================
# 来源: flowfields.txt
============================================================

## Flow fields
Let it flow (down the mountain).

Flow fields are available with the Heightfield Erode SOP, HeightField Slump SOP, but also a separate HeightField Flow Field SOP. You can, for example, use the fields as distortion layers for the HeightField Distort by Layer SOP. Another field of application for the layers is masking. Or you can use the fields for scattering rocks, trees, and other landscape elements. Flow fields are interesting for all kinds of erosion where material is removed and transported.

When you calculate a flow field, you'll get two layers: `flow` and `flowdir`. The first layer represents the cumulative material flow in voxel space. The second layer shows the average direction of flow at each voxel. The `flowdir` layer doesn't contain any height information. The image below shows the `flow` layer (white) of an erosion node.

## Flow fields - Example: Erosion channels
The following example illustrates how to use a flow field to create deep erosion channels through distortion.

[NOTE]
    All explanations and examples use a very basic terrain, consisting of a HeightField SOP and a HeightField Noise SOP to get some mountains and rocky structures. To get enough detail, set the heightfield node's Grid Spacing to `1`.

    For more information on how to work with this fundamental setup, please read the Generating a heightfield from scratch introduction.

# On the HeightField Noise SOP, turn off Center Noise, because you'll be using a Worley noise for the terrain that already comes with a vertical offset.
# Set Amplitude to `400`. This will slightly decrease the height of the mountains.
# Go to the Noise Settings section. From the Noise Type dropdown menu, choose Worley Cellular F1. You will now see a mountain range with sharp peaks and ridges.
# Lay down a HeightField Distort by Noise SOP and connect its first input with the output of the noise node. This node breaks up the regular fractal and creates small rocky structures.
# To get more detail, change Element Size to `75`.

### Flow

Here, you'll be creating the flow field that will later control the amount of erosion. You can consider the HeightField Flow Field SOP a modified HeightField Slump SOP. This node simulates how debris and lose material behaves when it's sliding down a hill and there's a separate chapter about this node.

# Lay down a HeightField Flow Field SOP and connect its input with the output of the distort node. After a couple of moments you'll see a red mask.
# Go to the Flow tab and change Slump Mode to Smooth. With this mode, the water spreads out in every possible direction.
# Change Rain Amount to `0.4` to simulate stronger precipitation. The mask now becomes slightly denser, because there's an increased probability for raindrops to cover larger areas of the terrain. With Rain Density you can also simulate different types of rain form normal to intense.

### Flow layers

As mentioned in the introduction, the flow field nodes creates several layers that represent how water spreads over the terrain, but there's also a `water` layer itself. The `water` layer is directly affected by the node's Rain Amount and Rain Density and where the water collects in the terrain.

You can use a HeightField Visualize SOP to make the flow field layers visible. Just use the visualize node's Layer parameters and apply a Color. The image shows the flow field node's layers: `flowdir.x`, `water`, `flow` and `flowdir.z`.

### Distortion

In this step you'll use the `flow` layer to scale the displacement of the terrain to control the size and depth of erosion channels.

# Add a HeightField Distort by Layer SOP and connect both inputs with the output of the flow field node. The second input makes the existing layers available to all relevant parameters.
# Open the Scale Field parameter's dropdown and choose `flow`. This field will be used to displace the terrain inside the masked area.
# Set Displace Scale to `2` to create deeper and more pronounced channels.

If you still think the channels are too deep or show tiny spikes, you can add a HeightField Blur SOP after the distortion node. Set Radius to `0.5` or `1` to keep as much detail as possible.

And to get rid of the mask, terminate the network with a HeightField Mask Clear SOP. The default entry for Layer 1 is already `mask`, so you don't have to change anything. Then turn on the node's blue Display/Render flag to see the final result.

============================================================
# 来源: hills.txt
============================================================

## Solitary mountains
Create custom hills and mountains where you need them.

The introduction's Generating a height field from scratch chapter explains how to create a complete terrain with hills and valleys. However, sometimes you only need a single hill or just more control where mountains should appear. You can, for example, use such a solitary mountain as a patch and merge it with another heightfield.

One solution is to draw a custom map, load it to Houdini and extrude it. The advantage is that you can directly add features by combining different layers inside an image processing software. The Heightfields from maps pages describes in detail how to create terrains from images. If you have to change something, you must redraw the map.

You can also project an object onto an empty heightfield, for example a cone or any other geometry that looks similar to a mountain. Then you can distort and erode the object to make it look natural.

Another method for creating a mountain is to open the Terrain FX shelf tool and click Terrain: Mountain. This tool uses heightfield projection.

Below, you can also find a workflow that scatters objects over an irregular area and uses a few lines of VEX code to create a mountain.

Finally, it's possible to use a certain type of noise from the HeightField Noise SOP and draw a mask to create a solitary peak.

## Solitary mountains - Masking method
You can create a mask through a HeightField Draw Mask SOP, a HeightField Mask Noise SOP or both. The mountain appears inside the red areas of the mask.

# On the obj level, create a HeightField OBJ. Double click the new node to dive inside, where you find the actual object.
# Lay down a HeightField Draw Mask SOP and connect its input with the heightfield's output.
# Hover the mouse cursor over the viewport and press Enter. You're now in drawing mode.
# Press and hold the LMB to draw an arbitrary shape onto the plane. Press Esc when you're finished and leave the drawing mode.
# On the mask node's Masking tab. increase Blur Radius to `50` to get smooth borders.

[TIP]
    For a more natural and eroded shape without a hard-edged plateau, set Blur Method to Box Blur.

### Remapping

To turn the mask into a mountain, you can remap the heightfield.

# Add a HeightField Remap SOP to your network.
# Connect the remap node's first input with the output of the heightfield. The second input is linked to the output of the mask.
# Increase Output Max to elevate the masked area. Start with a value of `400` to see a decent effect. The blurred edges create a smooth base.

Now you can apply any other heightfield node to shape the mountain, typically noise, distortion and erosion. Distortion is of particular interest, because it adds structure to the vertical "walls" of the mountain. 

You can also use the mask you've created to shape the mountain, to prevent the ground from being eroded. On the Main and Advanced tabs you can find Erodability and Removeal Rate Masks. Open their associated drop-down menus and choose Mask on. Then, substitute their default entry with `mask`.

## Solitary mountains - Scatter method
Instead of a mask you can also use any geometry and turn it into heightfield. The magic word is scattering, a method that is explained in detail on the Heightfield scattering page. Here you'll learn how to create an interesting base shape for a mountain.

The following method might appear a bit cumbersome and there are definitely faster and more convenient ways to create a mountain. But, the example is a concept that illustrates how to achieve a goal with alternative paths. It's also a very flexible method that has lots of knobs for customizing and randomizing your terrain.

The idea is to define an irregular polygon object that serves as a ground that is covered with points. Then you scatter a base object, e.g. a tube, across the points. The distance of each tube from the ground object's position determines its height: tubes, closer to the center are high, those near the object's borders are low. What you get is a mountain shape that you can project onto an empty heightfield.

### Mountain base

The base object's size and shape defines the foot of the mountain.

# On the obj level, create a Geometry OBJ. Double click the new node to dive inside.
# Add a Circle (Polygons) SOP. The circle will be deformed to create the irregular structures.
# Right now, the circle is oriented along the ZX plane. From the Orientation dropdown menu, choose ZX Plane.
# Turn on Reverse to make the circle's normals point upwards.
# Uniform Scale is the first parameter for customizing the mountain. Considering that a default heightfield is 1000 m by 1000 m, this value shouldn't be too small. Start with `300` to create a disk with a diameter of 600 m.
# Increase Division to `200` to get more edges and jags.

### Deformation

Noise is a common method to add variation to masks, object, point clouds, maps, etc. In this scene, noise will deform the base object.

# Add an Attribute Noise SOP and connect its input with the output of the circle node. You'll now see a disk with colored stripes.
# The colors come from the Attribute Names parameter's default `Cd` entry. Change the name to `P` for "position".
# Next to Attribute Names you can see XYZ buttons. Deformation should only be applied in XZ direction. Click the Y button to turn off the circle's Y direction.
# Go to the Noise Value section's Amplitude and change the value to `200`. Higher values create more distortion.
# The Noise Pattern section provides an Element Size parameter to control the amount of noise. Set the value to `250` for a moderate distortion.

[NOTE]
    You can also use a Point Jitter SOP to randomize the ground object's shape. The result will be pretty much the same.

Here's an image that shows the transformation from a circle to a polysurface.

### Translation

You can also see that the circle was displaced and its center is no longer in the scene's origin. This will, of course, affect the position of the mountain, so it's better to reset the object to the scene origin.

In contrast to vertex, point or primitive attributes, a detail attribute is a property of an object itself, not its components. An example: if you say "the ball is red" then you're talking about a detail attribute, because you mean the entire ball, not the individual components it's made from.

For the reset you need three lines of VEX code (yes, VEX scripts can be very short). It's possible to use a Transform SOP and click the Move Centroid to Origin to reset the object, but you always have to click this button when you change the circle's shape or scale. Therefore it's better to have an automatic position update.

# Add an Attribute Wrangle SOP and connect its first input with the output of the Attribute Noise SOP.
# On the Code tab, set Run Over to Detail (only once).
# Go to the VEXpression input field and enter

    
    vector base_pos = getbbox_center(0);
    
        f@base_pos_x = base_pos.x;
        f@base_pos_z = base_pos.z;

    The code calculates a position vector `base_pos`. To do this, you get the center of the bounding box around the deformed circle. The `(0)` part indicates that the function takes the object from the wrangle's first input. Then the script extracts the X and Z components of `base_pos` and stores them in appropriate attributes: `@base_pos_x` and `@base_pos_z`.

# Add a Transform SOP and connect its input with the wrangle's output.
# On the Translate.X parameter, enter `-@base_pos_x`. 
# For Translate.Z, type `-@base_pos_z`.

Now, the deformed circle will always sit exactly in the scene's origin.

### Scatter points

Scattering is the process of distributing objects over a surface or another object. Here you'll be scattering a tube and control its size with the help of a customized `pscale` attribute.

# Lay down a Scatter SOP and connect its input with the output of the transform node.
# Open the Options tab and go to Force Total Count. This parameter determines the number of scatter points and finally the number of tubes. Enter a value of `10000` to get a structure that is dense enough to create a solid object.
# For a less random distribution of points, increase Options > Relax Iterations to `100`.

### Instance object

The instance object in this example is a tube, but you can use any other object as well.

# Add a Tube SOP.
# Turn on End Caps to create a closed object.
# The lower cap should sit exactly on the heightfield's zero level. Go to Center.Y and enter `0.5`. This is half the tube's Height value of `1`.
# Put down a Copy to Points SOP. Connect its first input with the output of the tube, and the second input with the output of the scatter node.

When you turn on the copy node's blue Display/Render flag, you will see 10000, rather small, tubes with the same height and radius. Another VEX script lets you scale the tubes and create the outlines of a mountain.

### Scale control

To change the height of each instance based on its distance to the distorted circle's center you need another VEX script. This script also changes the tubes' diameter and contains custom parameters. A `ch[type]` statement introduces custom parameters,

# Add a new Attribute Wrangle SOP and place it between the scatter and copy nodes to connect its first input.
# Copy Ctrl+C the code below and paste Ctrl+V it to the VEXpression input field.

    vector peak_position = set(chf("offset_x"), 0, chf("offset_z"));
    
    float base_scale = chf("base_scale");
    float dist_scale  = exp(chf("steepness") * distance(peak_position, @P));
    
    @scale = set(base_scale, fit(noise(@ptnum), 0, dist_scale, 0, chf("height")), base_scale);

# Next to VEXpression click the  Create spare parameters... button to create the custom parameters.
# Use the following values for the custom parameters

    * Set Base Scale to `20` to create overlapping tubes.
    * Increase Height to `30`. This is the maximum height of the mountain.
    * With Offset X and Offset Y you can shift the mountain's peak.
    * Lower Steepness values create a more natural mountain. This parameter is very sensitive, so start with a value around `0.007`.

Here's the explanation of the VEX code.

    * `base_scale` is a custom float parameter that lets you define the tube's diameter.
    * `origin` is a position vector that uses custom `offset_x` and `offset_z` parameters to shift the mountain's peak.
    * `dist_scale` uses an exponential function and a tube's distance from the `origin`. This function creates a bell-shaped height distribution.
    * `@scale` defines the size of each tube instance. The X and Z components (= diameter) are defined by the custom `base_scale` parameter. The Y component determines a tube's height and that's a more complex expression. The `noise` function is responsible for the smooth look of the mountain.

        `fit` takes the original values that range between `0` and `height_scale`. The original values are mapped to a range between `0` and the product of the ramp values and the custom `height` parameter. To get a more realistic result, the function uses the current point number `@ptnum` to drive a noise function.

With Offset X set to `50` and Offset Z set to `200`,  you should get a mountain like in the image below.

### Projection

Now you can project the geometry onto the empty heightfield and apply some blur to seamlessly blend both objects.

# Add a HeightField Project SOP and connect its first input with the output of the HeightField SOP. Link the second input to the output of the Copy to Points SOP.
# The result is still a bit "blocky" (upper part of the image below), but you can smooth the surface with a HeightField Blur SOP (lower part of the image).

### Hilly landscape

The scattering method is not only good for a single mountain or hill, but also for complete landscapes. You can even use already existing point clouds with exactly defined positions to place the hills where you want them to appear. As scatter objects you can use cones, hemispheres or any other geometry - and combinations of different shapes.

With just a few scatter points and cones, for example, it's possible to create a mountain chain with summits and patch it to a base terrain.

## Solitary mountains - Noise and mask
The last method we want to discuss, uses a HeightField Noise SOP and mask. The idea ist to scale and shift the noise in a way to get just one or two peaks. Then you draw a mask to restrict the creation of the terrain to a certain area, and blur the mask to make the mountain fade out. You can improve the result by distorting and eroding the mountain as shown in the image below.

Of course, you can use the HeightField Noise SOP's default Noise Type called Sparse Convultion, However, to get a more natural appearance with peaks and ridges, change the dropdown menu to Worely Cellular F1.

# On the noise node, change Amplitude to `400`.
# Increase Element Size to `600`.
# For Offset, enter `0, 0, 500` to shift the noise pattern along the Z axis.
# If not already done, go to Noise Type and choose Worely Cellular F1.

### Masking

Now you'll draw a mask to fade out the terrain and create a mountain you can then use as a patch.

# Add a HeightField Draw Mask SOP and place it between the HeightField and HeightField Noise SOPs. Connect the mask's output with both inputs of the noise node.
# Hover the mouse over the viewport and press 2 to see the terrain from top view. Press H to center the heightfield.
# Now, press Enter to turn on the node's drawing mode. Use the LMB to draw a mask onto the heightfield grid. The mask doesn't have to be a perfect circle and it can even be irregular. You'll see a red area with surface structures inside.
# Leave the drawing mode with ESC.
# On the mask node, increase Blur Radius to `150` or more to get smooth edges.

Here you can see the result with the mask still visible.

============================================================
# 来源: layers.txt
============================================================

## Layers
Add realism by stacking layers and applying masks.

Layers are one of the most important concept with Houdini's heightfields. In fact, almost everything you do creates a new layer. You can also extract and combine layers, convert them into masks, drive parameters and separate different materials like debris and water. This guide gives you an overview about the most important concepts with layers. Layers are the essence of complex setups. There you define layers, combine and blend them, add distortion and features like terraces. All this together results in a realistic terrain.

You might ask if there's a difference between masks and layers? "Layer" is an umbrella term and a mask is a specific type of layer. This also applies to your terrain's height layer. Both layers are created with the heightfield. Click the heightfield node's Node info to see the layers. 

:fig:
    * `height` contains elevation values for every grid point of the HeightField SOP. This information is used to create the displacement.
* `mask` is only accessible when you connect a mask node to the HeightField Noise SOP's second input.

## Layers - Copying layers
Copying layers is an essential technique, for example if you want to convert a mask into a separate layer. Let's say you want to define a mask to drive thermal erosion. This is a typical scenario where you copy the mask to a new `thermalerodabilitymask` layer. This way you preserve the new layer and you're safe to override the `mask` layer with new information.

## Layers - Height and mask
The example below illustrates the concept for working with `@height` and `@mask` layers. The network creates a plateau at 20 meters and masks this area. Then, you copy the mask into a new `cliparea` layer.

[NOTE]
    Here, we assume that you have created a terrain already. If not, please read the Heightfield base and Heightfield noise chapters from the introduction to get started.

In most cases you'll use one of Houdini's heightfield mask nodes like HeightField Mask by Feature. In this setup you'll use a wrangle and a few lines of VEX to create a custom mask.

# Add a HeightField Wrangle SOP and connect its first input to the output of the existing network's last upstream node, most probably the HeightField Noise SOP.
# Use Ctrl+C to copy the VEX code below and paste it with Ctrl+V to the wrangle's VEXpression field. 

This short code snippet says that, if the terrain's height is greater than 20, it'll be clipped to 20 and the voxel will also be part of the `mask` layer. 

    if (@height > 20) {
        @height = 20;
        @mask = 1;
    }

Here's what you get when you turn on the wrangle's blue Display/Render flag.

### Mask to layer

Right now, the red area represents the global `mask` layer. In a small network like that it's ok to proceed with the `mask`, but in more complex scenes you'll most probably override the `mask` layer several times and lose information. You should therefore turn `mask` into a separate layer, e.g. `cliparea`.

# Lay down a HeightField Copy Layer SOP amd connect its input with the output of the wrangle.
# For Destination, enter `cliparea` and open the copy node's Node info to check the new layer.

The copy layer node lets you create extra layers with different information. You can, for example, create feature layers from the terrain's slope or occlusion, or paint masks and save them as separate layers. Later you can reuse the layers, for example as patches for another terrain or scattering.

### Layer to geometry

It's also possible to convert a layer's content into actual geometry.

# Put down a Convert HeightField SOP and connect its input with the output of the wrangle. This node converts the field information into polygons. The `cliparea` layer is now a point attribute.
# Use Density to control the mesh's resolution. Higher values create more polygons.
# Add an Attribute Wrangle SOP and connect its first input with the output of the convert node. Like the heightfield wrangle, this node also expects VEX code. This time, the script will create a `mesa` group from the `cliparea` points. Only points with an `@cliparea` value of exactly `1` will be added to the group and also receive a red color. Copy and paste the following code to VEXpression.

    
    if (@cliparea == 1) {
            @group_mesa = 1; // Add the point to a 'mesa' group
            @Cd = set(1,0,0); // Apply a red color to the point
        }

# Add a Blast SOP and connect its input with the output of the wrangle.
# For Group, enter `mesa` and turn on Delete Non Selected.
# When you turn on the blast node's blue Display/Render flag, you will see the result. What you get is a regular piece of geometry and you can connect it to any other SOP node.

## Layers - Combining heightfields
Especially with complex heightfields it's helpful to keep things separated and work on each layer independently. In this example you create a terrain with sharp ridges and a rocky base layer to become familiar with the basic concepts of how to combine layers. One method is to try to adjust the heightfield's noise function, perhaps add some erosion and hope for the best. Another, more convenient, artist-friendly and faster way is to combine two heightfields with different noise settings through a HeightField Layer SOP. 

[TIP]
    You can also find a complete example project, where combined heightfields help to create inclined and folded terraces, on the Terracing page.

One of the big advantages with this node is that the connected heightfields don't have to share equal Grid Spacing values. The layer node also provides a third input for a mask to define areas, where you want to merge the heightfield information.

Here's the network you'll be creating.

# Start with two HeightField SOPs and two HeightField Noise SOPs. Set the noise node's names to `worely` and `sparse` to make them distinguishable.
# Connect each heightfield to a noise node.
# Select the `worley` node and go to its Noise Settings section. From the Noise Type dropdown menu, choose Worley Cellular F1.
# Adjust Amplitude and Element Size for both noise nodes to your liking. There's no right or wrong.
# The Worley terrain is shifted along the negative Y axis. To compensate for this offset, add a HeightField Transform SOP. Connect its input with the `worley` node's output.
# Adjust Height Offset. The terrain's midpoint should roughly be around the scene's center.
# Lay down a HeightField Layer SOP. Connect its first input with the transform node and the second input with the `sparse` node's output.

### Blending

The result is a little disappointing, because now the sharp ridges of the Worley Cellular noise are gone. In fact you only see the terrain from the layer node's second input. To change this, open the HeightField Layer SOP's Layer Mode dropdown menu.

* Choose Add to sum up the `height` values of both terrains. This results in a terrain with higher peaks. You can go to the Remapping section and decrease Base Scale to flatten the terrain.
* Choose Blend for an averaged heightfield. The advantage with this mode is that you can use the Blend parameter to control how much a heightfield contributes to the final terrain. With `0.5` both heightfields have the same share of the overall result. When you drag the slider to left, you will see more and more of the terrain from the node's first input. You also have access to Base Scale to adjust the terrain's height.

Now you can create new masks, and apply erosion, distortion or terraces to the combined result. You can also add more HeightField Layer SOPs and blend in the information from other heightfields. This way it's possible to create very complex setups for highly detailed landscapes.

The image shows the heightfield from above with some additional masks and a HeightField Distort SOP. Distortion adds the fine details, while areas around the tops are smooth. The ridges are also blurred through a curvature mask to remove the sharp edges from the Worley Cellular noise. Such a landscape is suited for mountains with snow.

### Height control

Some Layer Modes create extreme height values and the entire terrain appears to be unusable. However, there's a method to level the values.

# On the HeightField Layer SOP, change Layer Modes to Multiply. What you get is a stretched terrain.
# Go to the Remapping section. There you can find Base Scale and Layer Scale parameters that let you scale the connected terrains individually on their inputs. Decrease the values until you've got the expected result. Depending on the terrain, you often end up with very small values like `0.01` or less.

## Layers - Combining masks
If you have gone through the Combining heightfields example, you might have noticed an asterisk entry on the HeightField Layer SOP's Layers parameter. The character indicates that *all* layers from the node's inputs are merged together. However, it's possible to select individual layers/masks from the parameter's associated dropdown.

The workflow is exactly the same as described with layers and the only real difference is that you replace `*` with the actual name(s) of your layer(s). You also have the same options for blending the layers by choosing a Layer Mode.

## Layers - Clearing and deleting layers
When you clear a layer, it won't be deleted, but you'll add a constant value to all voxels. To see the effect, add a HeightField Layer Clear SOP to your scene and connect it with the output of a HeightField Noise SOP. Then, do the following.

# For Layer 1, enter `height` or choose the layer from the associated dropdown menu.
# Now the terrain is completely even and every grid point has a height of `0`. Drag the Value slider to the right to increase height. You can watch how the plane offsets along the Y axis.

Clearing doesn't only work with `height`, but with any other layer and you can control multiple layers through a single node. If you want to clear several layers at once, increase Number of Clears and specify the appropriate layer(s). This also works for mask, but for masks you can also use the HeightField Mask Clear SOP instead. It's a preconfigured layer clear node.

If you really want to delete a layer, you need a Delete SOP. Removing a layer completely helps to free resources.

# Add a Delete SOP after the last node where the layer, meant to be removed, is required.
# Go to the Group parameter's associated dropdown menu and choose a layer, for example `mask`. The input field changes to `@name=mask`.
# Also make sure that Entity is set to Primitives.

============================================================
# 来源: lightmask.txt
============================================================

## Light masks
Create masks from the sunlit areas on a terrain.

It's possible to identify areas that are lit by sunlight and store the result in a mask layer. You can then use this information for scattering, texturing or atmospheric effects like haze or fog. The idea is to take the direction of a light source and see where it hits/illuminates the terrain. Here you can see scatter points in the masked areas.

Note that this solution is just an approximation, because some aspects are not considered, e.g. the sun's height above the horizon. However, there are methods to that, but they are more complex approach.

Create an arbitrary heightfield - the terrain's topography doesn't matter. If you want to learn how to get started with terrains, please read the Generating a height field from scratch chapter from the introduction to heightfields.

## Light masks - Light source
You also need a light source to calculate the map. This is not a physical light, but just an object that determines the direction of the light rays.

# Add a Sphere SOP or any other geometry.
# Use the Center parameters to position the object. You can also animate the parameters and watch how the map changes over time.
# If you have problems to identify the object in your scene, increase Uniform Scale.

## Light masks - Script
The script calculates the terrain's normals through a `volumegradient` function. Normal vector and light direction are then used to calculate the dot product. The dot product calculates the angle between two vectors and returns a scalar. You can then use the scalar value to define the mask.

To apply the script, lay down a HeightField Wrangle SOP. Connect its first input with the last input of the node that creates the terrain, for example a HeightField Noise SOP or HeightField Erode SOP. Then, use Ctrl+C and Ctrl+V to copy and paste the code below to the wrangle's VEXpression parameter.

    // Custom light source parameters
    vector light_pos = chv("light_pos");
    float light_intensity = chf("light_intensity");
    
    vector pos = @P;
    
    // Get the light's direction
    vector to_light = normalize(light_pos - pos);
    
    // Calculate the heightfield's normals and illumination
    // Use only the maximum values
    vector normal = volumegradient(0, "height", pos);
    float illumination = max(0, dot(normal, to_light));
    
    // Multiply illumination and intensity
    // Invert the mask to get the sunlit areas
    @mask = 1 - illumination * light_intensity;

To create the custom `light_pos` and `light_intensity` parameters, select the wrangle and press the  Create spare parameters for each unique call of ch() button. For Light Pos it's a good solution to transfer the light source's Center values to the new parameter.

# On the Sphere SOP, right-click the Center parameter. From the context menu, choose Copy Parameter.
#  Then, on the wrangle, right-click Light Pos and choose Paste Relative References. This choice adds expressions to the three parameters that read and transfer the sphere's position to the wrangle. When you change the sphere's position, the wrangle parameters will be updated automatically.

Light Intensity is a factor for scaling the mask values.

## Light masks - Processing the mask
We recommend adding a HeightField Mask Blur SOP to the network to get some control over the mask's softness and size.

You can also use a HeightField Copy Layer SOP to store the custom mask into a new layer, e.g. `lightmap`. This will help you a) to separate the mask and prevent it from being overridden, and b) to visualize the layer if necessary.

============================================================
# 来源: mandelbrot.txt
============================================================

## Mandelbrot set
3D fractals for entertainment.

This chapter is a gimmick and illustrates that you can do pretty fancy things with Houdini's heightfields. You might have heard about the so-called Mandelbrot set. The name giver is Benoit B. Mandelbrot, a Polish-French-American mathematician. The Mandelbrot set is a self-similar fractal that's based on complex numbers. The iconic element of the Mandelbrot set is a black area that reminds of an apple. The structures around the "apple" are color-coded to make them differentiable. Self-similarity means that you can "dive" into the fractal to reveal more detail, but you'll always see very similar patterns. The level of detail depends on the number of iterations.

With heightfields and VEX it's possible to translate the fractal patterns into height information and create a Mandelbrot-style landscape. Here's the script without further explanation. There's plenty of information about fractals in general and the Mandelbrot set on the internet.

    // Parameter definition
    int maxiter = chi("iterations");
    float scale = 1 / chf("scale");
    float offset_x = chf("offset_x");
    float offset_z = chf("offset_z");
    float escape_threshold = chf("escape_threshold");
    float amplifier = chf("amplifier");
    float core_height = chf("core_height");
    
    // Main rountine 'mandelset'
    function float mandelset(float x0, y0; int imax; float escape) {
        float x = 0;
        float y = 0;
        float xnew, ynew;
        int i;
    
        for (i = 0; i < imax; i++) {
            xnew = x * x - y * y + x0;
            ynew = 2 * x * y + y0;
            if (xnew * xnew + ynew * ynew > escape) {
                return float(i) / float(imax); // Normalized iteration depth
            }
            x = xnew;
            y = ynew;
        }
        return -1.0; // Points within in the Mandelbrot set
    }
    
    // Mandelbrot calculation
    float value = mandelset(@P.x * scale - offset_x, @P.z * scale - offset_z, maxiter, escape_threshold);
    
    if (value >= 0) {
        @height = value * amplifier;
        @height += sin(value * 10) * 0.1; // Bands
    } 
    
    else {
        @height = core_height;
    }

## Mandelbrot set - Parameters
The script is rather short, but provides a several parameters that let you customize the fractal. The last numbers in the table below are example values that produce a "standard" Mandelbrot set. On the Heightfield Wrangle SOP

table width="100%">>
    th width="15%">>Parameter
    th width="25%">>Description
    th width="10%">>Value

    tr>>
        td>>Iterations
        td>>The fractal's "resolution". Higher values take longer to calculate, but create more details. Note that the amount of visible structures also depends on the heightfield's grid size.
        td>>`200`
    tr>>
        td>>Scale
        td>>The size of the Mandelbrot set. You typically need values of `100` and more to see the fractal's structures.
        td>>`300`
    tr>>
        td>>Offset X/Z
        td>>The Mandelbrot set's normalized position. Normalized means that the offset values range between `0` and `1`. A value of `0.5` represents the midpoint.
        td>>`0.5 / 0`
    tr>>
        td>>Escape Threshold
        td>>Determines, when a point is no longer considered a part of the Mandelbrot set. This parameter creates the banding effect around the fractal. Higher values create more details, but take longer to calculate.
        td>>`800`
    tr>>
        td>>Amplifier
        td>>A scale factor for the structures outside a apple-shaped area. High values create the typical spikes.
        td>>`75`
    tr>>
        td>>Core Height
        td>>The height of the apple-shaped area in meters.
        td>>`100`

With the values above you get the image shown below. Height information is color-coded here with a HeightField Visualize SOP.

============================================================
# 来源: maps.txt
============================================================

## Heightfields from maps
Create detailed terrains from maps.

As a 3D artist you most probably know the concept of displacement maps, where color information is translated into height information. A typical application for displacement maps are ocean waves, digital elevation models or the creation of complex structures from a simple base geometry.

In contrast to bump maps, where the normal vector is altered to achieve the visual impression of irregularities, displacement maps create actual geometry. Heightfields, however, consist of volumetric data and the map's height information is stored in the base grid's points. When you use displacement maps, you have several ruling factors that determine the quality of your terrain. The most obvious parameters are grid resolution and map resolution. A 2K map for a small ground segment with sand and gravel is normally not suited for a huge terrain. And a terrain with grid points every 2 m will not show as many detail as a model with a point distance of 5 cm.

Another aspect is the used file format. You typically differentiate between 8-bit formats, and EXR or TIFF files with 16 or 32 bit. The more information your file stores, the better the resulting terrain. With 8-bit files you might observe banding or other patterns, caused by insufficient color information. 32-bit images create smoother surfaces. Anyway, for distant areas or ground planes covered with debris or grass, 8-bit images are often enough.

Finally, the surface's original scale also plays an important role. For example, a displacement map from a small section of a landscape doesn't look good, when you stretch it over an entire terrain. On the first look, the landscape below appears to be correct, because it has enough resolution. However, the original size of the displacement map is just 2 m by 2 m. When you consider that the map's features are magnified by a factor of 500, the image starts to look out of scale. The edge length of the red box in the middle is 10 m.

[NOTE]
    You can use maps in two ways: as a height layer or a mask layer. The latter option is discussed separately on the Masks from images page.

## Heightfields from maps - Basic setup
In order to use displacement maps you need a basic heightfield grid. The setup, described here, will be the basis for all following considerations.

# On the obj level, press Tab to open the tab menu. From there, create a Geometry OBJ node. Double-click the new node to dive inside.
# Now add a HeightField SOP. The map will be projected onto this base grid.
# Change Size to `4, 4` to create a small area that will serve as a ground.
# Decrease Grid Spacing to `0.002`. This value determines the distance between two grid points and lets you see even finest structures. The resulting grid consists of 8,000,000 voxels.

## Heightfields from maps - Loading the map
A displacement map adds detail to the flat grid. Houdini provides a separate node for loading maps. This node also lets you make several adjustments on the map and the height layer directly. The maps, used in this example, cover an area of 2 m by 2 m.

# Lay down a HeightField File SOP and place it between the already existing nodes from the basic setup to connect it.
# Next to File click the  Open floating file chooser button and load a displacement map. As suggested above, you should use 32-bit EXRs for best results.

    NOTE:
        With very large maps, you might see an `Image resolution too large` error on the HeightField File SOP. In this case you can go to the main menu's Edit entry and choose Preferences > Old Compositor. Then, open the Cooking tab and increase the Resolution Limit parameter.

# What you will get is pale red surface without surface structures. The reason for this look is found in the Layering section. There, you can see that Layer Name is set to `mask` and the map is therefore treated as a mask. To create surface structures, change the entry to `height`.

## Heightfields from maps - Size and height
The heightfield is now most probably shifted along the positive Y axis and maybe you can also recognize a few surface structures.

# Go to the Size section. There you can see that the Size parameter's default value is `1000`. This corresponds with the heightfield's standard dimension of `1000`. Enter `4` to restore the map's original size. The terrain is now centered in the middle and embossed, while the area around the map is completely even.

    It's possible to upscale high-res 8K or 16K displacement maps to a certain amount, but don't overdo things to avoid artifacts or blurred structures. A scaling factor of 1.5 to 2 works in many cases.

# To flatten the terrain, go to Height > Height Scale. The default of `1` is also tied to Houdini's standard terrain and way too large in relation to the small area. Start with a value around `0.1` - the actual value depends on the map's original scale.

The image shows a section of the pebbles map that was used here.

## Heightfields from maps - Layering: Border
In this example, base grid and map both have a size of 4 m by 4 m. The HeightField File SOP's Size parameter was also adjusted to `4` and now map and base grid are matching to get the correct scale. What if you load a 2 m x 2 m map and set Size to `2`, but leave the grid's size untouched? This combination creates an embossed effect you can see in the image above.

The Layering section provides some useful tools, e.g. for tiling or how an empty space around a terrain is treated. By default, Border Type is set to Constant. To compensate for the hard edge, you can adjust Border Value. To get a seamless transition from border to terrain, you can use an expression.

# Right-click on Height Scale. From the menu, choose Copy Parameter.
# Now, right-click on Border Value and choose Copy Relative References.
# The input field turns green and now contains an expression. To align border and terrain, change the expression to `ch("heightscale")/2`.
# You might have noticed that the entire heightfield was slightly moved upwards. To set the grid back to the scene's base level, select the HeightField SOP. Right-click on Initial Height and choose again Copy Relative References. This time, the expression is `-ch("../heightfield_file1/heightscale")/2`. Now, the grid is at Y=0 again.

    The idea of relative references is that you have to change a value once only and all referenced parameters will be updated according to the associated formula.

## Heightfields from maps - Layering: Tiling
In fact, tiling also belongs to the "border" topic, but is discussed separately due to its importance. Many displacement maps, esp. those from commercial repositories, are seamless and tileable. So, instead of scaling the map, you can repeat it to cover the entire heightfield area.

# The HeightField SOP's Border Type dropdown provides a Repeat option. Choose this entry for tiling the displacement map.
# The Position section's parameters let you change the map's Center and Rotate values.

Here you can see the 2 m by 2 m map from the Layering: border chapter above and how it's repeated to cover the 4 m by 4 m base grid.

## Heightfields from maps - Stacking maps
You're not limited to a single HeightField File SOP, and you can stack several nodes with different maps to create completely new terrains. Displacement maps also merge with other terrain-creating nodes like the HeightField Noise SOP. The biggest limitation is that, by default, there's no ready-to-use parameter for blending different maps. Each map contributes equally to the final result.

If you just want to stack maps, you can chain several HeightField File SOPs and make individual adjustments on them. The only thing to consider is that the Height Scale values of the various maps add up. In a scene with, lets say, three maps and Height Scale values of `0.02`, `0.03` and `0.05`, the base grid's Y position will be `0.1`. In this example, the HeightField SOP's Initial Height should be `-0.05` to reset the grid to the scene's origin.

Here you can see the stacking of the two maps used in the previous chapters.

## Heightfields from maps - Exporting maps and layers
The usage of displacement maps isn't a one-way street, but you can also export your heightfields and bake them into files.

# Add a HeightField Output SOP and connect its input with the output of your network's last upstream node.
# Go to Filename and click the  button to specify output name and directory. The file type is taken from the suffix you enter, e.g. `.jpg`.
# Turn on Resolution and enter the values for the number of pixels in X and Y direction. Choose values that can be divided by 8, e.g. `256`, `512`, `1024` or `4096`.
# Go to the Output Layers section. Next to the color channel parameters, you can see associated dropdown menus. For Red, Green and Red, choose `height`. If you also have an alpha mask defined, set Alpha to `mask`. Otherwise it's safe to turn off Alpha.

    Here you're exporting the `height` layer, but you can choose any other available layer.

# Click the Save to Disk button to write the map to disk.

============================================================
# 来源: masking.txt
============================================================

## Masking
Define zones of interest and detail.

Masks are one of the most important concepts in conjunction with terrains. Masks allow for the precise shaping of your terrain, but also for controlling parameters and attributes. The fact that there's a wide range of nodes, dedicated to masking, underlines the importance of masks. A mask lets you define, where to apply effects such as erosion or terracing. Masks always appear in red and everything inside the red area(s) will be affected or modified.

When you work with heightfields, you work with layers. A mask is basically nothing than a layer. You can create several mask layers and store them under different names for different applications. It's also possible to combine masks to a single layer, or reuse masks, created by nodes like the HeightField Terrace SOP to identify certain regions of interest. Blurring lets you create smooth masks, but there are also modes for expanding, shrinking and sharpen your masks without having to redraw them. Even blurring supports masking, and you can define exactly where the smoothing effect will occur.

You can draw and paint masks. You can also create masks by feature, geometry and occlusion. Another, very convenient way is to load a mask from an image file or Houdini's COP network. This method lets you draw detailed masks in your favorite image processing software and import it.

[TIP]
    Masks can become very complex and sometimes you have to deal with multiple masks. We therefore recommend to name your masks and nodes accordingly to make them identifiable.

Many nodes provide a separate input for connecting masks, like the HeightField Noise SOP or HeightField Layer SOP. The latter node lets you combine different terrains and you can draw a mask to control, where the heightfields are merged together.

As mentioned, you can also use masks to drive attributes and parameters. The HeightField Erode SOP, for example, provides support for several parameter masks. A dropdown menu indicates where you can apply a masks to control a parameter. The menu's default choice is Mask Off. When you choose Mask On, you will see an input field for a mask. Once you've connected a mask, the input field becomes accessible. You can also click the 

For a clean view of the final terrain it can be helpful to delete the mask. This will also help to save resources. To do so, add a HeightField Layer Clear SOP to your network. For Layer 1, enter `mask` to delete it.

## Masking - Painting masks I
This workflow gives you full control over all aspects of a mask. You can exactly define the mask's area, size, smoothness, and opacity. If you're not happy with the mask's shape you can completely reset your brush strokes or just erase certain parts. You can profit from all features from Houdini's paint tools.

# Add a HeightField Paint SOP. Connect the paint node's output to the second input of the node you want the mask to be applied.
# Hover the mouse cursor over the viewport and press Enter to turn on the node's brush mode. A red sphere indicates the brush. Use the mouse_wheel to change the brush's size.
# Move the mouse over the terrain with the LMB pressed to draw the mask. Your motions create red strokes on the terrain's surface.
# To change the mask's opacity/transparency, go to the node's Opacity value. A value of `1` means full opacity, while `0` is full transparency.

The default Paint Mode is Replace. When you paint over an already masked area, e.g. with an increased FG Value of `0.2`, the brush removes the original mask and creates a new one in these areas. With Add, however, you will really add new parts to a mask. When you paint over an existing mask, the mask values will sum up.

You can also use the brush as an eraser. To do this, make sure that Paint Mode is set to Replace. Then, change FG Value to `0` and paint over the region of interest.

[TIP]
    You can directly control FG Value by clicking and dragging the MMB. This way you can draw fine nuances in the mask without leaving the viewport.

There's also a live mode. For example, with the standard setup, turn on the HeightField Noise SOP's blue Display/Render flag. Then, click the paint node and turn on the draw mode as described in step #2 above. When you draw the mask, you can see the result of your action directly in the viewport.

:video:
    #src: /videos/heightfields_paint_mask1.mp4

## Masking - Painting masks II
Maybe you've noticed that some heightfield nodes have a  Add a Mask Paint button. An example for such a node is the HeightField Terrace SOP. Sometimes it's active, sometimes not. Unfortunately, there's no consistent rule. When the button is inactive, connect the upstream node's output to the second input of the node with the paint button.

When you click the button, Houdini adds a HeightField Paint SOP and connects it automatically. Now you can paint the mask. Your options and tools are the same as described above.

## Masking - Object masks
The HeightField Mask by Object SOP lets you use arbitrary geometry to create a mask. The object is projected onto the terrain and you'll see a cross section of the connected geometry. You can combine several objects through a Merge SOP to create complex and individually shaped mask. HeightField Mask by Object provides some interesting features. You can

* directly blur the mask without a separate HeightField Blur SOP
* invert the mask
* create animated masks by moving or deforming the mask geometry
* add the geometry mask to or subtract it from an already existing mask when you set Combine with Existing to Add.

The screenshots shows an example setup with a HeightField Mask Noise SOP, subtracted from a geometry mask.

## Masking - Image masks
You can also create images inside your favorite drawing/painting application or import any image and use it as a mask. Another method is to assemble a mask in Houdini's COP network. A nice feature of image-based masks is that colors are converted into opacity values. This way you can precisely control the strength of the effects you apply to shape your terrain. And you can also create complex patterns.

# To import a file, add a HeightField File SOP to your network and connect it. 
# Click the  Open floating file chooser button to load an image from disk. This *doesn't* have to be a grayscale image.
# Sometimes, images turn out pale or details are hardly visible. In this case, consider the choose another Channel to enhance contrast.
# From the Type menu, choose Mask.
# Control the dimensions of the image with Size > Size. The value is given in meters and corresponds with the Heightfield SOP's own Size parameters.

If you want to use a COP-based image instead, set Source to COP. On the COP Network parameter, click the  Open floating file chooser button and navigate to the COP node you want to convert into a mask.

It's also possible to combine image-based masks with other, already existing masks. On the Layering section you can find a Layer Mode menu with several options. The image map's content doesn't play a role and Houdini will convert any image into a mask.

## Masking - Noise masks
A noise mask is a fast way to create a random mask with spots or areas of different size. Basically, noise masks work like any other noise-based node or function in Houdini. You choose a noise type and then you adjust the noise pattern through various parameters. The main difference to other nodes, e.g. the Attribute Noise SOP, is the missing Animation section.

* To create a noise mask, add a HeightField Mask Noise SOP to your network and connect it.
* With Element Size you can control the noise pattern's size. Smaller values produce more spots. This is a global size factor, while Scale lets you stretch or squeeze the pattern differently along its axes.

As with other types, you can combine noise masks with other, already existing masks. The Combine Method provides several options, e.g. for adding or subtracting masks to create complex patterns.

## Masking - Feature masks
Terrains have various characteristics like height, slope or curvature. You can use these features for the creation of masks. Feature masks use natural properties, they create convincing results. You can also combine multiple features without losing control. Each feature has its own set of parameters and a customizable ramp.

* Add a HeightField Mask by Feature SOP and connect it.
* Turn on the feature(s) you want to include to generate the mask and make your adjustments.

Again, you can combine a feature mask with other, already existing masks by the choosing one of the mode from the Combine with Existing dropdown menu.

## Masking - Combining masks
Most mask-based nodes provide a Combine with Existing dropdown menu that lets you choose from different methods to merge different masks. Now, imagine a scene with two masks, e.g. a HeightField Paint (`A`) and a HeightField Mask By Feature SOP (`B`).

The dropdown menu's default method is Replace. When you turn on the blue Display/Render flag for mask `B`, you will only see this mask. Mask `B` replaces mask `A` and the painted mask is no longer visible.

Now, choose Add from the menu. What you get is a combination of mask `A` and `B`. There are also modes for subtracting, multiplying and blending masks, along with some others.

Masks don't have to range between 0 and 1, but you can also apply values greater than 1. The strength of a mask has direct influence on your terrain or its attributes.

## Masking - Mask layers
In many situations you need more than just one mask. The problem, however, is that Houdini's heightfields only have one `mask` layer. What, if you want to create masks for different purposes or effects? What, if you need various types of masks to feed a VEX script? There's a standard workflow for turning a `mask` layer into a new layer.

You start with the creation of a default `mask` layer, for example through a HeightField Mask by Feature SOP. There you choose one of the features like Mask by Curvature and then you want to save the result in a separate `curvature` layer. 

# After you've specified the mask, add a HeightField Copy Layer and connect its input with the output of the mask node.
# On the copy node, go to Destination and enter the name of the new layer. Here, it's `curvature`.
# If you don't want to override the original `mask` layer, add a HeightField Mask Clear SOP. This node doesn't delete the `mask` layer, but sets its values to 0.

To make the new `curvature` layer visible, lay down a HeightField Visualize SOP. There you can see nine Layer parameters with associated dropdown menus. You can open any menu and choose curvature. The layer should appear in the viewport with the corresponding color. If you're not happy with the color, you can change it, of course.

## Masking - Clearing masks
Clearing a mask doesn't mean that the mask will be deleted, but you assign a constant value to each mask point instead.

# Add a HeightField Layer Clear SOP to your network and place it after the node where the mask was used for the last time.
# Go to Number of Clears and enter the number of masks you want to clear. The node will create a parameter set for each layer/mask you want to work on.
# Each Layer (n) parameter provides a dropdown menu. From there you can choose the appropriate mask.
# Use the Value (n) parameter to determine the constant mask value. When you enter `0`, the mask layer will still be present, but won't affect your heightfield operation(s).

## Masking - Deleting masks
If you want to delete a mask (or any other layer), you can use a Delete SOP. Let's assume you've created an `erosionmask` mask. Now you don't need it anymore, so you want to delete it completely and free memory.

# Add and connect a Delete SOP to your network at that point where the mask is no longer required.
# Go to the Group parameter's associated dropdown menu on the right. From there, choose `erosionmask`. The entry changes to `@name=erosionmask`.
# If you only want to keep `erosionmask` and delete any other layer (including `mask`, `height`), set Operation to Delete Non-Selected.

[NOTE]
    Instead of a Delete SOP you can also use a Blast SOP.

## Masking - Parameter masks
You can use masks to drive parameters. Some parameters, for example Erosion Rate or Deposition Rate on the HeightField Erode SOP's Hydro section, have associated dropdown menus. The default choice is Mask Off, but when you choose Mask On, you'll be able to enter the name of a mask that will control the parameter's influence.

============================================================
# 来源: nodes.txt
============================================================

## Heighfield nodes
Houdini's set of heightfield nodes.

The compilation below gives you an overview of the available heightfield nodes and what they do.

## Heighfield nodes - I/O
* heightfield_file loads height data from a 2D elevation map.

* lidarimport can load LIDAR formats (for example e57) as height fields.

* heightfield_output writes height data to a 2D elevation map.

* heightfield_quickshade adds materials to terrain based on layers and masks, for rendering.

* heightfield_scatter scatters points across the 3D surface represented by a height field. This is useful for distributing 3D geometry such as trees/plants across the terrain, or converting the height volume into a point cloud.

* heightfield_tilesplit splits a layer into multiple tiles. This can be useful for distributing work, for working on smaller pieces at a time, or for exporting tiles to game engines.

* heightfield_tilesplice combines tiles into a single layer.

## Heighfield nodes - Adding features to terrain
* heightfield_layer composites one height layer over another, allowing you to "paste" a feature into a larger field. The node will properly composite volumes that aren't axis aligned, so you can position and rotate the volumes in 3D space before compositing.

* heightfield_project raises or lowers terrain in the shape of 3D geometry.

* heightfield_paint lets you paint elevation values into a height layer by hand.

* heightfield_pattern generates repeating patterns such as stripes. It includes distortion controls which can make the geometric patterns look more organic. Adding these patterns into a height layer with a mask can create interesting details in terrain.

## Heighfield nodes - Conditioning terrain
* heightfield_blur smooths out details in terrain.

* heightfield_noise and heightfield_distort add random detail to terrain.

* heightfield_clip flattens areas above and/or below a certain height, for example to create tableland (mesa/tapui).

* heightfield_terrace creates flattened steps up slopes, creating looks like terraced farms or waterfall rock formations.

## Heighfield nodes - Simulating natural processes
* heightfield_erode simulates the process of erosion, creating natural-looking features.

* heightfield_slump simulates the process of loose/piled soil moving downhill.

## Heighfield nodes - Making and editing masks
* heightfield_drawmask lets you draw masked areas by hand.

* heightfield_maskbyfeature creates masks based on criteria such as elevation, facing direction, or slope. For example, you can create a mask layer representing snowfall only above a certain elevation and only on a certain side of a mountain.

* heightfield_maskbyobject creates a mask from the intersection of a height layer and some 3D geometry.

* Height Field Mask Noise creates a customized Height Field Noise set up to add noise to a mask layer, which can make it look more organic.

* Height Field Mask Clear creates a customized Height Field Layer Clear set up to clear the mask.

[NOTE]
    If you see odd results when masking nodes, try using Heightfield Isolate Layer or Heightfield Visaulize's Custom Tinting range to verify the values in the mask are from 0-1 (inclusive).

    Values from 0-1 appear as red tint in the mask visualization. Zero values appear white, but negative values and values greater than 1 also appear white. If a mask doesn't behave as expected it might be because it contains out-of-range values.

## Heighfield nodes - Layer utilities
* heightfield_xform moves and rotates the fields in world space.

* heightfield_visualize lets you visualize elevation values using a color ramp.

* heightfield_remap "redistributes" height values in a layer into a new range, based on a ramp.

* heightfield_resample changes the resolution of a field's underlying grid.

* Height Field Wrangle is an alias for Volume Wrangle. It lets you edit the values in a height volume using a VEX snippet.

* Height Field VOP is an alias for Volume VOP lets you build a VOP network to edit the values in a height volume.

* heightfield_copylayer creates a new layer by copying an existing one.

* heightfield_layerproperty sets layer options such as how to compute values outside boundaries of the field (Border type).

* heightfield_layerclear resets the values in a layer to 0.

* heightfield_isolatelayer

============================================================
# 来源: painting.txt
============================================================

## Painting terrains
Be an artist and paint your landscapes.

You can create a basic heightfield and use other nodes to refine its look. Then you can also import displacement map and elevate the base grid. Another method is to draw and paint heightfields directly inside Houdini. Heightfield painting is perfectly suited for creating trenches, riverbeds, and elevations in particular areas. Instead of height information you can also paint masks to spare out certain areas from being modified. This way you can, for example, draw streets.

When you paint a heightfield, you normally don't draw each and every tiny detail. Instead you paint a basic shape and then you start working on the heightfield through noise, erosion, etc. to make your landscape look natural.

## Painting terrains - Example: Riverbed
The following basic example illustrates how to paint a dry riverbed and blend it with various nodes to add surface detail. In this scene you'll make use of Houdini's drawing features to paint the terrain and a mask that defines where terraces will appear. You'll also reuse the mask to drive erosion.

Let's start with the terrain.

# On the obj level, press Tab to open the tab menu. From there, create a Geometry OBJ. Double-click the node to dive inside it.
# Lay down a HeightField SOP and change its Grid Spacing to `1` to get enough detail.
# Add a HeightField Paint SOP and connect its input with the output of the heightfield node.
# Go to Layer. By default, the node lets you paint a mask, but here we want to create a riverbed. From the parameter's associated dropdown, choose `height` to replace the default entry.
# For FG Value, enter `-60` to create an impression. Positive values, however, let you paint hills and elevations.
# Hover the mouse cursor over the viewport. Press Enter to turn on the paint mode and to see a spherical brush. You can change the size of the brush interactively by scrolling the mouse_wheel up (bigger) or down (smaller).
# Press Esc to leave the drawing mode.

You'll immediately see the result of your action and a canyon-like structure. You can add as many strokes as you want, change the brush size with each new stroke or alter parameters like Opacity. 

### Blurring

A closer look at the riverbed reveals a flat area at the bottom, although Soft Edge is already set to `1`. 

# To fix the edges, add a HeightField Blur SOP. Connect its first input with the output of the paint node.
# Change Method to Box Blur. This mode creates slightly better results, esp. along the hard edges at the bottom.
# Drag the Radius slider to the right to increase the value until the edges are completely smooth.

### Adding structures

Right now, the terrain completely lacks surface structures. The advantage with procedural node-based systems is that you can add nodes anywhere in the network. Heightfields are no exception and you can chain as many nodes as required to create complex landscapes. The layer system in heightfields also allows for the manipulation of selected parts through masks.

In this example, you'll add distortion, terraces, noise and erosion. A mask will help you to apply the erosion effect only to the hillsides of the trenches.

==== Noise and distortion ====

Noise is the most fundamental method to create a terrain. In this example, noise should be moderate to keep the look of the trenches. With high settings you will distort the trenches and destroy the impression of a riverbed that dug its way through a large mesa.

# Add a HeightField Noise SOP and connect its first input with the output of the terrace node.
# To roughen the terrain, set Amplitude to `40` and Element Size to `75`.
# Then, lay down a HeightField Distort SOP and connect its first input with the noise node's output.
# The goal is to add more structure to the terrain, but keep its character. A moderate Amplitude of `4` and an Element Size of `50` create nice results.

==== Masking ====

In this step you'll paint one common mask to drive terracing and erosion. The process of painting a mask is almost identical with terrain painting.

# Lay down another HeightField Paint SOP and connect its input with the output of the HeightField Distort SOP. The difference to the first draw node is that you'll be drawing on the `mask` layer instead of the `height` layer.
# Hover the mouse over the viewport, press Enter and start drawing as before. Press Esc to confirm your work.
# Add a HeightField Mask Blur SOP and connect its first input to the new paint node. Change Radius if necessary to get a smoother mask.

Below you can see a possible result. You might have noticed that the mesa parts are completely spared out to prevent them from becoming eroded.

==== Terracing ==== (terracing)

The next structures you're adding, are terraces. In nature, rocks from lower layers are compressed through overlaying layers and therefore harder. The softer upper layers are eroded faster and create terraces. You can mimic this effect in Houdini.

# Add a HeightField Terrace SOP and connect its first input with the output of the upstream HeightField Noise SOP node. Link the second input to the output of the mask blur node. Now, the terraces will only appear inside the red areas.
# Click Compute Range. This button calculates the height range where the terraces will occur to give you an idea about the terrain's vertical dimensions. Use Min Height and Max Height to determine, where you want to create terraces.
# Max Step Size changes the number of terraces. With smaller values you create more steps.
# To get rid of the hard edges, increase Smooth Edges, but don't overdo the effect: later, when you apply erosion, the terraces will become smoother as well.
# There's also a hard transition from the terraces to the terrain. To get a smooth transition, open the Terracing tab and go to Fade Ramp. Click the  Presets button to see a list of predefined curves. For this terrain the Valley preset is perfectly suited. The curve smooths the bottom and top terraces, but maintains the look of the inner layers.

==== Erosion masking ====

Erosion is the result of external influences like water, wind and temperature. Wind and water carry away the debris. The movement makes the stones smaller and smaller and finally they become sand. In riverbeds you can often observe accumulations of sand near boulders or ditches, because the sand is heavier than water. This difference lets the sand sink and settle. On the land, however, sand is transported by wind and comes to rest when there's an obstacle. This can results in dunes.

In this scene, erosion will be limited to the slopes of the trenches through the already existing mask.

# Add a Heightfield Mask Expand tool from the tab menu. This tool is a preconfigured HeightField Blur SOP, where Method is set to Expand. Connect its first input with the output of the terrace node.

    When you go to Blur Layer, you will see that the default entry is `mask`. Leave the default, because it already specifies the mask from the terrace node.

# Increase Radius to control the mask's expansion. The mask can also cover small parts of the mesa. This scene uses a value of `15`.
# Lay down a HeightField Erode SOP and connect both inputs with the output of the blur node. Adjustments will be made directly below.

==== Controlling erosion ====

The new HeightField Erode SOP in Houdini 21 provides a wide range of parameters that let you precisely control this process. Here, we're going to make only a few changes, because we don't want to erode all the nice terraces.

# Select the HeightField Erode SOP and make sure that the Solver tab is open.
# Decrease Erosion Feature Size to `3`. This value is measured in meters and creates rather narrow drains. Higher settings would wash away all fine structures.
# For Flow Force, enter a value of `0.5`. This is the force of erosion that's induced by water. With values, smaller than `1`, the drains won't be so deep.

As you can see, the terraces "survived" the erosion process, but not completely, and you can still guess their shape.

==== Adding details ====

# Put down a HeightField Mask Clear SOP and connect its input with the output of the erode node to set all `mask` values to zero.
# Add another HeightField Distort SOP and connect its first input with the output of the mask clear node.
# Set Amplitude to a moderate value of around `6`.
# Increase Element Size to create slightly bigger noise patterns. Values around `120` should give good results.

You can also add another erode node to make it slightly smoother, and give your terrain an even more natural look as in the image below.

============================================================
# 来源: patching.txt
============================================================

## Patches
Assemble terrains with patches and cutouts.

The HeightField Patch SOP lets you stitch different heightfields together and create something entirely new. You translate and rotate the patch to place it exactly where you need it. Patches are a convenient method to create terrains that are difficult to achieve with a single heightfield, e.g. if you want to have valleys or plain areas in certain regions. You can also create a solitary mountain and place it where you want it to exist. Patching is perhaps the best way to achieve full control over a terrain.

You need a mask to define the area you want to use as a patch. Te mask's shape and properties also control how the patch will be added to the base terrain. A blurred mask cares for a smooth transition between base and patch terrain.

Of course you can "stack" several patches to create extremely complex heightfields that are impossible or at least very difficult to achieve with masks. You can apply erosion or slump, and use maps to the patches and distort to modify the patched landscape.

Another thing to consider is that all layers from patches are deleted - except `height` and `mask`. If you, for example, add erosion to the patch, the node will also create a wide range of layers like `sediment` or `water`. These layers are no longer available on the patch node.

## Patches - Example: Landscape
In this example you'll combine two basic heightfields. The result is a feature-rich with flat areas and eroded parts with many small structures that blend into each other. Erosion and distortion create the terrain's final look.

### Heightfields

The introduction says that you'll combine two heightfields, but both terrains are derived from a single HeightField SOP. To reveal more details, decrease Grid Spacing to `1`. For the image above, Grid Spacing was even lowered to `0.5`.

To create different landscapes, you need two HeightField Noise SOPs. Rename the nodes to `noise_base` and `noise_patch`. Connect the first input of each noise to the heightfield grid node's output. You only need to adjust `noise_patch`.

# Change Amplitude to `225` to get slightly higher mountains.
# With Element Size you control the size of the noise pattern. A value of `1000` removes the high-frequency noise and creates a rather flat area with just a few hills.
# For Offset.X, enter `-80` to shift the mountains along the negative X direction.

Here you can see the two noise types in action.

### Base distortion

Distortion is one of the most effective means for adding detail to a terrain and get more structures.

# Lay down a HeightField Distort by Noise SOP and connect its first input to the output of the `noise_base` node.
# To add some nice structures, change Amplitude to `60` and Element Size to `450`.

What you get is a terrain with lots of ridges and small features.

### Patch mask

A mask defines where the patch will be added to the base terrain. This will finally create the flat areas between the mountains. The mask is already blurred by default and creates a smooth transition. As always with heightfield masks, red determines the areas where something happens. This means that the patch (= the flat terrain) will appear in the red areas. You can adjust the mask to your liking and there's no wrong or right.

Add a HeightField Mask Noise SOP and connect its first input with the output of the `noise_patch` node. What you get should look similar as in this image.

### Patching

The HeightField Patch node brings the two network streams together and uses the noise/patch mask to determine where the heightfields are merged.

# Add a HeightField Patch SOP to the network. Connect the
    * first input with the output of base network's HeightField Distort SOP
    * second input with the output of the patch network's HeightField Mask Blur SOP.
# To balance height differences, set Height Scale to `0.5`. This will scale down the height values of the patch terrain even more.

If you're not happy with the position of the patch, you can use patch node's Positioning parameters. Here you can even rotate the patch. Below you can see the raw patches with the overlying mask.

### Erosion

Right now, the landscape really looks as if it was patched or stitched together. Even the mask's smooth borders can't remove this slightly artificial look completely. Erosion helps to "connect" the two terrains. To protect the plain areas, erosion will only happen in the rocky parts and again, the mask's blurred edges will create a smooth transition.

# For the erosion mask, you can use an inverted version of the already existing patch mask. Add a HeightField Mask Invert SOP and connect its input with the output of the HeightField Mask Noise SOP.
# Now, lay down a Heightfield Erode SOP and connect its first input with the output of the `noise_patch` node. The second input goes to the invert node's output.

You can proceed with the default settings or play with the erosion parameters. That's totally up to you. In order to get a more natural look, it's a good idea to add another HeightField Distort SOP. Some moderate Amplitude and Element Size values will create another level of detail and maintain the look of the plain areas.

Finally, add a HeightField Mask Clear SOP to set all mask values to `0` and make the mask invisible.

============================================================
# 来源: patterns.txt
============================================================

## Patterns
Create realism from basic geometric patterns.

Patterns are a convenient way to create exotic landscapes, but also realistic terrains like dunes. Furthermore, you can patch patterns to other heightfields, or use a certain structure as a starting point for something more complex.

You can apply patterns through the Heightfield Pattern SOP and choose from six different modes. The following examples show you how to use patterns to create certain terrain structures.

[NOTE]
    All examples start with a HeightField SOP on Houdini's obj level. Create the node and double-click it to dive inside. This will be the basis for your networks.

## Patterns - Example: Desert field
The HeightField Pattern SOP provides modes that are suited for the creation of a typical desert field with eroded hills, ripples and rocks that stand out from the sand. This example combines two patterns to get structures of different size.

### Hills

The first "layer" creates the large hill structures and a mask will break the pattern. The mask cares for a more natural look, because wind is often shielded by obstacles like rocks and this results in height differences.

# Set the HeightField SOP's Grid Spacing to `1` for a higher resolution.
# Add a HeightField Pattern SOP and connect its first input with the output of the HeightField SOP.
# Open the Pattern section's Pattern dropdown menu. From there, choose Ramp to generate a saw tooth pattern.
# Decrease Height to `30`. This will flatten the pattern.
# On the Position section, change Size to `190`. Instead of nine steps you'll now see just five edges.
# On the Ramp Remapping ramp, click the  Presets button. From there, choose Hill. 

The pattern is now a smooth and wavy surface.

### Shaping the hills

The hills should be formed by wind, similar to dunes. Dunes also have a specific profile: there's a steep slope on the windward side. On the wind shadow side, however, you can see how the sand is blown away and forms a stretched trail. You can recreate this characteristic shape when you modify the Ramp Remapping curve.

Click the little triangle below the  icon to expand the parameter section. Now you can enter an exact Position for each control point to shape the curve.

# Click the left slider. For Position, enter `0.15`. This will shift the slider to right.
# For the slider in the middle enter Position value of `0.3`.
# Finally, click the right slider. Here, Position will be `0.7`. Now, the waves follow the new profile. Your curve should look as in the image below.

    

# On the Distortion section, turn on Distort Pattern. You'll immediately see a change, but the pattern is still too regular.
# To create strongly curved structures, set Amplitude to `850`. This value results in a noisy surface, because the noise pattern is quite small.
# To get rid of the spikes, increase Element Size to `700`. The hills look better now, but they're still too irregular.
# Decrease Roughness to `0.2` to smooth the edges and create a regular structure.

### Masking

# Lay down a HeightField Mask Noise SOP and connect its first input with the output of the heightfield. Link the output with the second input of the pattern node. The node will now sit between the heightfield and the pattern nodes. The mask flattens the hills and creates irregularities.
# To create more noise, decrease Element Size to `140`.
# For more contrast, open the Post Processing section and set Gain to `0.98`.

### Ripples

The ripples overlap the hills and you can reuse the noise mask to create height differences. The ripples also add extra detail to the hills and later you'll see how the ripples create nice structures in conjunction with erosion.

# Add another HeightField Pattern SOP and connect its first input with the output of the already existing pattern node. Link the second input with the output of the mask node.
# From the Combine with dropdown menu, choose Add to merge the ripples.
# Set Pattern to Stripes.
# The ripples should only support the dunes and some more structure. Therefore, decrease Height to `7`. You can now see parallel bands that cover the hills.
# On the Position section, change Size to `20` and create more ripples.
# Go to the Distortion section and turn on Distort Pattern.
# Set Amplitude to `25` to get higher "waves".
# With an Element Size of `125` you can remove the high-frequency noise.

### Blurring

The terrain in its current state pretty jagged and ripples also show rather hard edges. Some moderate blur will help to remove artifacts, but keep the overall impression.

# Put down a HeightField Blur SOP and connect its first input with the output of the last pattern node.
# Change Radius to `3.5`.

### Noise

Right now the terrain's base is entirely flat, but it'd be nice to have some more structure. The HeightField Noise SOP adds an irregular rock surface with highly customizable peaks and hills. This fundamental node is part of almost any heightfield network.

# Add a HeightField Noise SOP and connect its first input with the output of the blur node.
# The terrain shouldn't be too high, so set Amplitude to `200`.
# For Element Size, enter `300` to get more noise.

### Erosion and distortion

The HeightField Erode SOP brings everything together and creates a realistic terrain. The default settings, however, create rather disappointing results. 

# Lay down an erosion and connect its first input with the output of the noise node.
# To get stronger erosion, increase Freeze at Frame to `60`.
# The erosion channels are very wide and there's hardly any detail. For smaller structures, set Erosion Feature Size to `3`.
# With Spread Iterations you can control the material transport. With `80`, for example, you'll get bigger sediment areas that fill the space between the hills.
# On the Hydro tab, decrease Flow Force to `0.5` to get less erosion from water.

A Heightfield Distort by Noise SOP breaks the erosion pattern and gives everything a more rocky appearance.

## Patterns - Example: Trench
You can use the HeightField Pattern SOP to create a trench with debris and sediment, flowing down its slopes.

# Add a HeightField Pattern SOP and connect its first input with the output of a HeightField SOP.
# Go to the Pattern section's Pattern dropdown and choose Ramp.
# On the Position section, go to Size and enter `500`. You'll now see a surface with a single "saw tooth". Then, turn off Repeat.
# On the Ramp Remapping ramp, click the  Presets button. From there, choose Valley.
# To move the deepest point of the trench to the grid's midpoint, go to the Position section and set Phase to `0.5`.
# Change Height to `300` and get a really deep canyon.

You might have noticed that the new height shifted the grid along the positive Y axis. If you want to level the surface again, set Base Height to `-300`.

### Shaping the terrain

Lay down a HeightField Noise SOP and connect its first input with the output of the pattern node. You can proceed with the default values or apply a different look. This is totally up to you.

The next steps create the usual noise to get peaks and the rough structures of a rocky terrain. The terrain from the image uses four alternating nodes: erosion -> distortion -> erosion -> distortion. The first erosion node adds large structures with an Erosion Feature Size of `30`. Distortion breaks the pattern, while the second erosion node adds the detailed trenches with a feature size of `10`. Another distortion node is responsible for the small structures on the smooth erosion area.

The result is a canyon with nicely shaped and feature-rich cliffs.

## Patterns - Example: Adding slope
The HeightField Pattern SOP is perfectly suited to create inclined terrains. From the node's Pattern, choose Steps. Then, set Step Height to `0`.

With Rise over Run you can control the slop's inclination, while Rotate lets you tilt the terrain. A value of `1` creates a grid with an inclination of 45 degrees.

============================================================
# 来源: projection.txt
============================================================

## Projection
Make any geometry part of a heightfield.

The HeightField Project SOP lets you add arbitrary geometry to your heightfield. You can define custom mountain shapes, add plateaus in specific locations, or create patterns.

Projection uses rays to catch the original geometry's shape. This also means that occluded areas that can't be seen by rays, won't be projected. You'll get a solid "wall" in those areas instead. This is due to the fact that heightfields are 2D objects with height information and there's no displacement in the XZ plane. When you project an object, you just add an offset to the grid's already existing height information. The quality of the projection also depends on the resolution of the HeightField SOP's Grid Spacing parameter. Large spacing creates alias effects and jagged edges.

However, the projected geometry is an integral part of the heightfield and you can apply noise, terraces, distortion, etc. Furthermore it's not only possible to add geometry, but you can also subtract an object and create impressions like footprints or the caldera of a volcano.

With the project node's Max Ray Dist parameter it's also possible to project parts of the object: all parts above the adjusted value will not be considered.

## Projection - Masking
When you take a look at the HeightField Project SOP's parameter set, you can see a Mask Mode toggle. The image below shows the Test Geometry: Rubber Toy SOP projected onto an empty heightfield. The project node sends out rays along the Y axis and this creates the typical look with vertical "walls".

When you turn on Mask Mode, the projection will only happen within a cross-section of the object, because the layer sets the Density value. You can control the final value, by changing Density. With values smaller than `1`, the cross section will gradually disappear. It's also possible to use values greater than `1` to increase the plateau's height.

[NOTE]
    The HeightField Projection SOP does not provide an input for external masks. This means that you can't restrict the projection to certain areas by defining a mask.

## Projection - Example: Rocky maze
You can use the combination of scattering and projection to create complex patterns and terrains with just a handful of nodes. When you change the scatter geometry or its distribution, you can also quickly create different versions and looks. Blurring, distortion, and other heightfield modifiers also help to achieve a realistic look. In the following example you'll use basic cubes to create a maze from mountains and rock.

[TIP]
    On the Solitary mountains page you can also find more sophisticated examples that uses scattering and projection to create a customizable mountain.

Everything starts with a HeightField SOP to create an empty terrain. The only parameter to change is Grid Spacing. A value of `1` will reveal finer structures.

### Scatter object

The following nodes are the network's centerpiece. The idea is to scatter instances of a base object over the heightfield grid. Here, the base object is a cube. By randomizing position and scale it's possible to generate a pattern of partially overlapping cubes and achieve complex structures.

# Lay down a Box SOP from the tab menu.
# Change Uniform Scale to `30` to get a really big object.
# Then, set Size to `3, 0, 0` to stretch the cubes along the X axis. The idea is to avoid very thin and sharp structures by creating a wider base.
# To make the cube sit perfectly on the flat heightfield grid, go to Center.Y and enter `15`. This is half the height of the cube.

### Scatter points

The HeightField Scatter SOP creates scatter points and lets you randomize several parameters like scale and orientation to avoid regulars structures.

# Add a HeightField Scatter SOP.

    When you turn on the node's blue Display/Render flag, you can see a very dense point cloud with roughly 227.000 points. At this state you will also create the same amount of instances. Therefore, it's necessary to decrease point count to a sensible number.

# From the Scatter Method dropdown menu, choose Total Point Count using Mask Layer. This option lets you determine an exact number of points in the Scattering section.
# Change Total Point Count to `500`.
# Go to the Variability and Relaxation sections. For Range enter `0.5, 2`. This will apply a random scale factor between 0.5 and 2.0 to the original box. You can also randomize the boxes' orientation with Randomize Up and Randomize Yaw. 
# Connect the scatter node's first input with the output of the HeightField SOP. Link the third input with the output of the Box SOP.

Now you'll see 500 overlapping boxes of different size and orientation covering more or less the entire terrain.

### Projection

This steps modifies the base grid to include the boxes and make them part of the heightfield.

# Add a HeightField Project SOP.
# Connect the project node's first input with the output of the HeightField SOP. Make sure that the heightfield node now has two connections.
# Connect the second input with the output of the scatter node.

The boxes are now part of the heightfield and you can start to shape the terrain.

### Shaping the terrain

You're free to shape the terrain with any node available and experiment with different settings. A good start, however, is to distort the result of the projection. This will add the actual structure and shape to the terrain, but it can be very noisy. To iron out the spikes, you should blur the heightfield.

# Start with a HeightField Distort by Noise SOP and connect its input with the output of the project node.
# From the Noise Type dropdown menu, choose Simplex. This noise type is similar to Perlin noise, but creates smoother results. Curl would add to much distortion.
# Play with different Amplitude and Element Size values, e.g. `600` and `375`.

### Blurring

Now you can see lots of artifacts at the rocks' "walls", but you can also get a first impression of how the terrain will look.

# Put down a HeightField Blur SOP to smooth the terrain. Connect its input with the output of the upstream distortion node.
# Change the Method dropdown menu to Box Blur. This mode creates softer edges and a more organic look.
# With Radius you determine the amount of blurring. Higher values will take more voxels into account and you'll get a smoother impression. Try a value around `6`.

Houdini's HeightField Erode SOP and a second HeightField Distort by Noise SOP will help you to finalize the look of the terrain and add more detail.

## Projection - Mountains
You can also create mountains with standard SOP geometry like a Grid SOP and a Mountain SOP. With geometry you have completely different possibilities to deform an object. Methods that aren't available with heightfields, because you can work on individual vertices and polygons. The Mountain SOP also supports animation, something that the HeightField Noise SOP doesn't provide.

The workflow for projecting mountain geometry is the same as with any other object.

## Projection - Adding slope
By default, an empty heightfield is always aligned with two axes, e.g. ZX or YZ. There are Center parameters to shift the terrain's position within the chosen plane, but you can't rotate the terrain around X, for example.

To create an inclined heightfield anyway, you can use projection. Note that this approach doesn't rotate or add inclination to features like noise or other projected objects: mountains will still "grow" vertically along the Y axis.

# Create a HeightField SOP. You can leave the default settings.
# Add a Box SOP.
# Change Size to `1000, 0, 1300`.
# For Center, use `0, 290, 0` to move the box upwards.
# Now, set Rotate to `30, 0, 0` to rotate the box 30 degrees around the X axis.
# Lay down a HeightField Project SOP and connect its first input with the heightfield node's output. Link the second input with the output of the box.

Now you have a heightfield with an inclination of 30 degrees and you can proceed to add noise, distortion, etc.

[TIP]
    Another method for adding slope is to use a HeightField Pattern SOP.

============================================================
# 来源: resampling.txt
============================================================

## Resampling
Increase terrain resolution step by step.

A common workflow with Houdini's heightfields is to start at low resolutions to create a terrain's larger structures and increase resolution for the fine details. The node for this process is the HeightField Resample SOP.

The most important advantage of resampling is certainly speed, because changes on a terrain with 2.5 million voxels will simply take longer than on a terrain with 500,000 voxels. You can gradually increase the heightfield's resampling resolution as you add more and more of the finer structures.

One of the most obvious issues is that you'll lose many of the detail the various nodes create, for example from the HeightField Distort by Noise SOP. Another issue with resampling is that you might introduce artifacts or regular patterns. It's not always possible to get rid of these unwanted structures completely.

To get more control over the number of voxels, we also recommend that you turn on the resample node's Specify Exact Resolution option. There you can choose from two Division Mode settings. This is very convenient, because you can synchronize this mode with the HeightField SOP's own Division Mode. Then you can decide whether you want to subdivide the terrain with a Grid Spacing or Grid Samples parameter.

The decision whether you want to resample your terrain is totally up to you, but for complex setups with multiple erosion levels, resampling can be a time saver. The comparison below shows a high-resolution heightfield with 28 million voxels. The terrain on right image uses three cascading resample nodes with different settings and has 25 million voxels. The differences are rather small, although the high-res version looks slightly crispier.

Another application for the HeightField Resample SOP is also downsampling, for example if you want to load a terrain to a game engine. You start with a high-res terrain and for export you can decrease resolution step by step until you've found the perfect balance between level of detail and file size.

============================================================
# 来源: sandtransport.txt
============================================================

## Sand transport
Shape terrains with wind and sand.

The following script simulates the transport of sand through wind and is an example for a more complex VEX script. The script's mechanisms are just approximations and don't have a physical background. Nevertheless, you can achieve nice results with the adjustable parameters. The script also shows that you can realize ideas even without sophisticated numerical methods.

## Sand transport - Terrain
The terrain setup requires a HeightField SOP to define the landscape's size and resolution. To increase surface detail, set Grid Spacing to `1`. For the mountains and terrain structures, add a HeightField Noise SOP and connect its first input to the output of the upstream heightfield node.

You can leave most of the noise's default settings. The only modification affects the Amplitude parameter. Change it to `300` to level the terrain and avoid extreme height differences.

## Sand transport - Solver
The simulation will be running inside a Solver SOP. This node is very convenient, because it saves you from dealing with complex time step calculations and stability issues. You "only" have to add your VEX code and the solver will do the rest.

# Lay down a Solver SOP and connect its first input with the noise node's output. 
# Double-click the solver to dive inside. There, add a HeightField Wrangle SOP and place it between the `Pre Frame` and `OUT` nodes to connect its first input.

[TIP]
    You might want to add a HeightField Distort by Noise SOP to terminate the heightfield network. This will help to break regular patterns and add structures to the flattened terrain.

## Sand transport - Code
The following VEX code contains the solver's functionality. We won't go through each function separately, but you can find information in the script's comments. A `//` string introduces a comment.

Use Ctrl+C to copy the code below. With Ctrl+V you can paste the script to the wrangle's VEXpression field. The program contains definitions for six custom parameters. To add the parameters to the wrangle's UI, click the  Creates sparse parameter for each unique call of ch() button.

    // Define the custom parameters
    
    float base_angle_deg = chf("wind_angle");
    float variation_pos_deg = chf("angle_variation_pos");
    float variation_neg_deg = chf("angle_variation_neg");
    float turbulence_strength = chf("turbulence_strength");
    float wind_strength = chf("wind_strength");
    float wind_shear_factor = chf("wind_shear_factor");
    
    // Calculate the wind direction with variance
    // This part converts the angle's degrees into radians.
    // The offset calculates a random value from time, position and an arbitrary vector. The result is then remapped to values between variation_neg_deg and variation_pos_deg.
    // The get final wind direction, the values are added.
    
    float base_angle_rad = radians(base_angle_deg + 180.0);
    float angle_offset = fit01(rand(@Time + dot(@P, set(12.345, 67.89, 0))), -variation_neg_deg, variation_pos_deg);
    float final_angle = base_angle_rad + radians(angle_offset);
    
    // Main wind vector with turbulence
    // The sine and cosine values of final_angle are assembled to a vector.
    // A curlnoise function adds small-scale turbulence to the wind.
    // The three vectors wind_dir_base, wind_turbulence, turbulence_strength are normalized to get a direction instead of a magnitude.
    
    vector wind_dir_base = set(cos(final_angle), 0.0, sin(final_angle));
    vector wind_turbulence = curlnoise(@P * 0.1 + @Time);
    vector wind_dir = normalize(wind_dir_base + wind_turbulence * turbulence_strength);
    
    // Wind shear
    // The wind shear has a 90° clockwise rotation in the XZ plane.
    // The wind shear strength is the product of wind_strength and wind_shear_factor.
    
    vector cross_wind_dir = normalize(set(-wind_dir.z, 0.0, wind_dir.x));
    float cross_strength  = wind_strength * wind_shear_factor;
    
    // target_pos determines the target position of the current voxel's sand
    
    vector target_pos = @P + wind_dir * wind_strength + cross_wind_dir * cross_strength;
    
    // Probability factor
    // To get a more random appearance, the script calculates a transport probability for each voxel.
    
    float prob_factor = fit01(rand(@Time + dot(@P, wind_dir)), 0.5, 1.0);
    float transport_prob = wind_strength * prob_factor;
    
    // This part samples the terrain's height values at the target position and the current voxel's position.
    
    float target_height = volumesample(0, "height", target_pos);
    float current_height = volumesample(0, "height", @P);
    
    // Set the terrain's height at the current voxel
    // The script checks if a voxel's sand will be moving based on the previous samples and calculations.
    // If the sand moves, the script determines if the sand is removed or accumulated.
    // If sand is removed, the amount of sand is directly converted into the terrain's actual height.
    
    if (current_height > target_height) {
        if (rand(@P + @Time) < transport_prob) {
            float sand_amount = current_height - target_height;
    
            if (sand_amount > 0.0) {
                current_height -= sand_amount;
                target_height  += sand_amount;
    
                @height = current_height;
            }
        }
    }

## Sand transport - Parameters
The script provides a several parameters that let you customize the environmental consitions. Here's what they do.

table width="100%">>
    th width="20%">>Parameter
    th width="80%">>Description

    tr>>
        td>>Wind Angle
        td>>The wind direction in degrees. A value of `0` means that the wind blows from west to east. With `90` degrees, direction is exactly from north to south.
    tr>>
        td>>Angel Variation Pos
        td>>The positive variation of the wind direction in degrees. Higher values create more variation. The value is added to Wind Angle.
    tr>>
        td>>Angel Variation Neg
        td>>The negative variation of the wind direction in degrees. Higher values create more variation. The value is subtracted from Wind Angle.
    tr>>
        td>>Turbulence Strength
        td>>The amount of wind turbulence. Higher settings can create unwanted artifacts. Start with a value around `0.3`.
    tr>>
        td>>Wind Strength
        td>>The wind speed. This parameter doesn't have a unit and is just a dimensionless factor. Higher values accelerate the sand transport. Good values range between `0.3` and `0.9`, but higher settings will work as well.
    tr>>
        td>>Wind Shear Factor
        td>>The script also applies a wind shear that is perpendicular to the adjusted Wind Angle. The final value is calculated as `Wind Strength * Wind Shear Factor`.

Once you've adjusted the parameters, you can go to the Playbar and click the  Play button to start the simulation. The script should be rather fast and in most cases you won't have to simulate for more than 50-70 frames.

============================================================
# 来源: scatterattribs.txt
============================================================

## Scattering: Attributes
Use attributes for controlling scattering instances.

You can write attributes to the scatter points to control the behavior of the instances and their shaders. Typical attributes are `orient` and `pscale`, but it's also possible to randomize colors. Or you maybe you want to store distances, height values, temperature and wind direction? Your possibilities are endless. You can also override existing attributes such as `pscale` with VEX code or appropriate nodes.

[NOTE]
    In Solaris/USD, attributes are called primvars (short for primitive variable) and some attributes are also named differently in Solaris.

This part of the scattering chapter explains how to apply custom `hue` and `saturation` attributes to drive the colors of a shader. In the last chapter you'll then read out the attribute values and connect them to your material.

The process of defining and creating attributes is basically the same as for any other geometry inside Houdini. One common way is to create an attribute and define its type. Then you randomize the attribute values over the points.

This guide represents page two of a four-pages workflow description about scattering.

* Scattering: SOP illustrates how to prepare your scene.
* Scattering: Removing points shows methods for controlling the number of scatter points.
* Scattering: Attributes creates attributes like `pscale` and `orient`.
* Scattering: Solaris shows how to create instances.

## Scattering: Attributes - Isolating points
With heightfields, however, there's one thing to consider. Click the HeightField Scatter SOP to select it and open the Geometry Spreadsheet. In Points mode, look at the first two entries, `0` and `1`. They describe the heightfield and when you apply attributes, the terrain will be considered as well. What does that mean?

Let's assume you've applied a random `Cd` color attribute. The circumstance that the heightfield is represented through two points will result in a colored terrain. It's therefore a good idea to store scatter points and heightfield in separate streams. Then you can go on and write attributes to the scatter points without falsifying the result. This workflow is not only convenient for attributes, but for the entire processing pipeline in Solaris.

On the HeightField Scatter SOP, go to the Relaxation section and turn off Keep Incoming Terrain. Now, the viewport shows only the scatter points.

## Scattering: Attributes - Scale and orientation
On the HeightField Scatter SOP you can find a Variability section with a Range parameter. Here you can define minimum and maximum scale factors for each point. In fact you're changing `pscale` here. The Method dropdown menu also provides three options for adjusting scale.

If you have already worked with the Scatter and Align SOP, you most probably heard about the `orient` attribute. This attribute controls a instance's rotation values around the base object's normals and other axes. The HeightField Scatter SOP works similar and you can find the appropriate parameter's in the Relaxation section.

According to the help, the Randomize Up parameter "specifies the number of degrees to jitter the computed normal direction of the instance.". In plain words, this parameter avoids that all instances are perfectly aligned with the terrain's normals. Imagine a forest where are all trees are exactly perpendicular to the ground. This is something that hardly occurs in nature and some trees grow at 94 degrees, others are have partially fallen, some grow at 85 degrees and so on. Randomize Up lets you mimic this behavior.

The Randomize Yaw parameters rotates the instances around the terrains normal. Yaw ensures that not all objects face the same side.

The requited normals are calculated on the fly by Houdini when you add a scatter node. However, you can influence the normals' direction with the Match Normals with Terrain and Match Direction with Slope parameters.

Of course, you can override both attributes anywhere in your network, for example with VEX scripts or appropriate nodes (see directly below).

## Scattering: Attributes - Hue and saturation
To define the `hue` attribute, you lay down an Attribute Create SOP. Connect the new node to the scatter node. Then, on the Attribute Create SOP, change Name to `hue`. The remaining parameters don't have to be changed, because the new attribute is a float that lives on the scatter points.

Then, add an Attribute Randomize SOP and connect its input with the output of the create node. On the randomize node you need a couple of settings.

# For Attribute Name, enter `hue`.
# Go to the Distribution tab and set Dimensions to `1`. This value represents the aforementioned float.
# Now you'll be choosing Min Value and Max Value. The attribute should control the saturation of a texture map. You typically change color-related values within narrow limits to achieve subtle change. Try `0.9` and `1.1` to avoid unnatural colors.
# For the `saturation` point attribute you can repeat all the steps explained above. You need one more Attribute Create SOP and one Attribute Randomize SOP.

    Since a value of `1` represents the original saturation, you only change Min Value. A value of `0`, however, creates grayscale map and this is normally not what you want. A good values is, for example, `0.7`. Houdini will now add random values between 0.7 and 1.0 to the points.

On the HeightField scattering: Solaris page you'll see how to connect the color correction attributes to a shader.

## Scattering: Attributes - Deleting attributes
With high particle counts and lots of attributes you bind computer resources you might need for the rendering process. When you delete the unneeded attributes, you can save time and memory.

You can use the Attribute Delete SOP for this task. There, go through the various (...) Attributes parameters and enter the attributes you want to remove. You can also choose the attributes from the parameters' associated dropdown menu.

## Scattering: Attributes - Last steps
Now you can add Null SOPs to make certain parts of the network more accessible, e.g. when you import SOP geometry to the Solaris stage. Here, you're going to use one Null for the heightfield and one for the scatter points.

# Lay down a Null SOP and connect its input with the output of the network's last node. This is most probably an Attribute Delete SOP. Rename the new node to `POINTS`.
# Add another Null SOP and connect its input with the output of the HeightField Noise SOP. Change its name to `TERRAIN`.

============================================================
# 来源: scatterptremove.txt
============================================================

## Scattering: Removing points
Get full control over scatter points.

The HeightField Scatter SOP creates points on the entire surface according to your settings. And sometimes, there are points and places where you don't need them. Of course, you can create masks to remove points, but in some cases it's not so easy to create an appropriate mask. A good example is the area outside a camera frustum. There might also be occasions where you want the scatter points to fade out towards the terrain's borders.

This page is part two of a four-pages guide to heightfield scattering:

* Scattering: SOP illustrates how to prepare your scene.
* Scattering: Removing points shows methods for controlling the number of scatter points.
* Scattering: Attributes creates attributes like `pscale` and `orient`.
* Scattering: Solaris shows how to render your terrain.

For the some examples, VEX scripting is a convenient way to remove unwanted points.

[TIP]
    If you're interested in VEX scripting for heightfields in general, please also take a look at the VEX scripts for heightfields page.

## Scattering: Removing points - Masking
[NOTE]
    There's already a description on the Scattering: SOP page. This chapter is for your convenience so you don't have to switch between different pages.

Masking with scatter points on heightfields works in the exact same way as masking in general. To be precise: masks don't delete points, but instead you define areas where points will appear. Here's a very basic setup for a scatter mask, assuming that you've already created a HeightField SOP.

# Lay down a HeightField Mask Noise SOP (or any other mask node) and connect its first input to the output of the heightfield.
# Add a HeightField Scatter SOP. Connect its first input with the output of the heightfield. Then, link the second input with with output of the noise mask.
# Turn on the scatter node's blue Display/Render flag to see the result.

With the mask node's default values you will notice a blank spot, while the rest of the terrain is covered with points. A closer look reveals areas of varying density. You can influence point density directly with the noise node's Amplitude parameter. With

* values, smaller than `1`, you'll enlarge the blank areas
* a value of `2`, for example, you'll get a very dense structure.

Now, change Element Size. This parameter controls the size of the noise pattern. Smaller values create more noise and also more detail. The image below uses an Amplitude of `1.5` and an Element Size of `200`. The result is a realistic point distribution.

[NOTE]
    You can also apply all the scripts, presented below, to a masked heightfield to further decrease the number of scatter points and create interesting effects.

### Scatter Method

The HeightField Scatter node provides a Scatter Method dropdown menu. The first three entries also support a Mask Layer to control the number of points. The default choice is By Coverage using Mask Layer and you can see the result in the image directly above. When you change Coverage, you can remove or add points.

By Density using Mask Layer works in the same way as the "by coverage" method, but here you have a Density parameter.

Finally, there's Total Point Count using Mask Layer. Here you set a fixed number of points. Your mask can cover the entire terrain or just a small area of 10%: the number of points will always be the same.

## Scattering: Removing points - Preparing the nodes
Since we're dealing with points here, you'll apply the scripts through a Point Wrangle SOP instead of a HeightField Wrangle SOP. The steps to create the appropriate nodes and add the scripts are always the same.

# Add a Point Wrangle SOP and connect its input with the output of the last upstream node.
# Use copy Ctrl+C and paste Ctrl+V to add the code to the VEXpression field.
# Click the  button to create the custom parameters.

## Scattering: Removing points - Border points
The first script removes points from a terrain's borders within a customizable area. You can also choose, whether you want to create a soft or a hard transition. The points aren't deleted here, but stored inside a separate group. Just in case you need them again somewhere else. The script

* adds custom parameters to define the scatter area's limits in X and Y direction
* adds a random `offset` to quickly create a smooth transition towards the edges
* compares a point's position against the borders of the scatter area
* removes the points within the seam.

Here is the VEX code. As always, this is just one method to write such a script.

    float limit_x = chf("limit_x");
    float limit_z = chf("limit_z");
    float offset = chf("offset");
    float seam = fit01(random(@ptnum), -offset, 0);
    float border_x = limit_x + seam;
    float border_z = limit_z + seam;
    
    if (@P.x > border_x || @P.x < -border_x || 
        @P.z > border_z || @P.z < -border_z) {
            removepoint(geoself(), @ptnum);
    }

To apply the above code and delete the border points, do the following.

# For Limit X and Limit Z enter, for example, `480`. This creates a frame with a width of 20 m around a standard heightfield of 1000 m x 1000 m.
# Set Offset to `100` to get a smooth transition of scatter points towards the terrain's borders.

## Scattering: Removing points - Camera frustum
A very common method for saving resources is to delete points outside a camera frustum. The concept is basically the same as in the Border points example above. The main difference is that you need a special vector that transforms a position to the normal device coordinates ("NDC") for a camera. Houdini's VEX has a built-in function to perform this transformation automatically: `toNDC`. You can also use this function with a light source instead of a camera. The script

* takes a custom camera to calculate the transformation
* lets you define a seam to create a safety buffer around the visible area
* compares a point's position against the X and Z components of the NDC vector to identify points outside the frustum
* deletes the points directly.

The good thing with this script is that it works with animated cameras, because the per-point attributes will be maintained. This avoids that scales or the instance objects themselves change with each new frame. 

The problem, however, is that the entire heightfield is removed at a certain position. When you open the Geometry Spreadsheet pane's  Points mode, you'll see that the first two entries have several attributes with a value of `0`. These two entries belong to the heightfield.

To avoid that the script deletes the heightfield by accident, go to the scatter node's Relaxation section. There, turn off Keep Incoming Terrain. Later you can use a Merge SOP to bring points and terrain together again.

For this feature you should use two Attribute Wrangles, because you must read a camera path and doing this for every scatter point is not very efficient. It's better to fetch the camera with a Detail Attribute Wrangle. For convenience reasons you'll also create a Seam parameter here. Add it to the network before the point wrangle that removes the points!

This is the VEX code for the detail wrangle:

    s@campath = chs("camera_path");
    f@seam = chf("seam");

Click the  Creates spare parameters for each unique call of ch() button to create the parameters.

# In the viewport, find a nice view of the terrain.
# In the upper right corner of the viewport, you can see two menus. Open the No cam menu and choose New Camera. This will create a `cam1` camera object on the obj level.
# For Camera Path, enter `/obj/cam1`. This is the location of the newly created camera from step 2.
# Change Seam. With `0`, you can delete points exactly along the outlines of the frustum. With values, greater than `0`, you create a safety buffer outside the frustum.

On the point wrangle, enter the following VEX script:

    vector camera_ndc = toNDC(s@campath, @P);
    
    float border_min = 0.5 - f@seam; 
    float border_max = 0.5 + f@seam;
    
    if (camera_ndc.x + seam < 0 || camera_ndc.x - f@seam > 1 ||
        camera_ndc.y + seam < 0 || camera_ndc.y - f@seam > 1) {
            removepoint(geoself(), @ptnum);
    }

In the image below, the particles outside the camera frustum are displayed in red to make the result more obvious.

[TIP]
    You can also store the particles outside the frustum to a group instead of deleting them. 

    Replace `removepoint(geoself(), @ptnum)` with `@group_outsidepoints = 1`;

## Scattering: Removing points - Camera distance
You can also remove points based on a point's distance from a camera. Instead of drawing a mask, you can just increase distance with a slider and get rid of unwanted points. Note that you'll get a circular or arc-shaped border. The script

* lets you define a custom distance threshold
* queries the camera's position in world space
* calculates the distance between the camera and the scatter points
* removes the points beyond the given threshold
* uses the custom Seam parameter to create a soft transition.

Since we're again dealing with positions, it can happen that the heightfield itself disappears. To avoid this, turn off the heightfield node's Keep Incoming Terrain option.

As with the camera frustum you also need a detail wrangle to initialize some parameters an values. Here's the script that also includes all relevant parameters. The `4@camera_matrix` calculates a 4x4 matrix. Doing this for every scatter point would drastically slow down the process. By defining `@camera_matrix` as a one-time detail attribute, the distance calculation becomes really fast.

The script calculates the camera matrix with the help of the optransform function. This, more advanced approach is necessary to compensate for a camera-specific offset.

    // Calculate a 4x4 transformation matrix
    4@camera_matrix = optransform(chs("camera_path"));
    
    f@dist_threshold = chf("distance_threshold");
    f@seam = chf("seam");

Click the  Creates spare parameters for each unique call of ch() button to create the parameters.
When you create a camera from the viewport in a fresh scene, Camera Path is `/obj/cam1`. The Dist Threshold value for the image below is `800` and Seam was set to `200` to achieve a smooth transition.

And here's the script for the point wrangle:

    vector camera_position = set(0,0,0) * 4@camera_matrix;
    
    float seam = fit01(random(@ptnum), f@seam, 0);
    float point_distance = distance(@P, camera_position);
    
    
    if (point_distance > f@dist_threshold - seam) {
        removepoint(geoself(), @ptnum);
    }

In this image, the points outside Dist Threshold are displayed in orange.

## Scattering: Removing points - Occluded points
The Camera distance script lets you delete points based on their distance to a camera. This is helpful, but not always effective. A more selective method can delete occluded points. The script sends out a ray from the camera to test for intersections with the terrain. Points that are are occluded by mountains or other geometry will be deleted. 

[NOTE]
    For this method you need a HeightField Noise SOP that creates mountains.

The script

* lets you choose a camera object
* queries the camera's position in world space
* calculates the camera's direction
* calculates a point's distance from the camera
* sends out rays based on the distance and direction to find occluded points
* uses the `tag` attribute to prevent the heightfield itself from disappearing.

As before, you need a detail wrangle and a point wrangle. Here's the detail code:

    // Calculate a 4x4 transformation matrix
    4@camera_matrix = optransform(chs("camera_path"));

Click the  Creates spare parameters for each unique call of ch() button to create the parameters.
In a fresh scene, the default Camera Path is `/obj/cam1`.

To make the frustum and distance point removal scripts work correctly, you've deleted the terrain. For this method, the heightfield is essential, because you need the "geometry" to calculate the occluded areas. This means that you must exclude the two points that define the heightfield. One method is to use the `tag` attribute that's created by the scatter node. The heightfield points don't carry this attribute and you can check if it's empty.

    vector camera_position = set(0,0,0) * 4@camera_matrix;
    vector camera_direction = normalize(camera_position - @P);
    float camera_distance = distance(@P, camera_position);
    
    vector pos, uvw;
    
    int hit_test = intersect(0, @P, camera_direction * camera_distance, pos, uvw);
    if (hit_test != -1 && s@tag != "") {
        removepoint(geoself(), @ptnum);
    }
    
    if (hit_test != -1) {
        removepoint(geoself(), @ptnum);
    }

Here you can see a terrain with occluded points removed.

============================================================
# 来源: scattersolaris.txt
============================================================

## Scattering: Solaris
Import your heightfields to Solaris and render them in Karma.

You've spent a lot of time to shape your terrain and now you want to render it. For this purpose you'll be importing terrain and scatter points into Solaris and render everything with Houdini's internal Karma render engine.

This is the last page of the heightfields scattering guide:

* Scattering: SOP illustrates how to prepare your scene.
* Scattering: Removing points shows methods for controlling the number of scatter points.
* Scattering: Attributes creates attributes like `pscale` and `orient`.
* Scattering: Solaris shows how to create instances.

[NOTE]
    This part of the heightfield scatter guide only deals with certain aspects of Solaris that are required to bring your geometry into Solaris. If you want to know more about Solaris, USD and Karma in general, please read the appropriate parts of the doucmentation.

    Please also note that the provided workflow is just one method to assemble a scene in Solaris and there are many other ways. If you're familiar with Solaris/USD, feel free to use your own technique. This also includes names and paths.

[TIP]
    Before you start to create your render network, we recommend changing Houdini's desktop. From the main menu bar, open the first dropdown menu (set to Build by default) and choose Solaris or Solaris LookDev. It's important to have access to the Scene Graph Tree, where you can see the scene's primitives and their hierarchy.

## Scattering: Solaris - Heightfield import
You've prepared your SOP network and now you're ready to go. Let's start with the terrain, because it's the basis for everything.

On Houdini's stage level, create a SOP Import LOP. The SOP Path parameter's  opens a floating window with a tree representation of your scene. Navigate to the container with the heightfield and choose `TERRAIN`. Confirm you choice with Accept.

The node imports the terrain as a volume. If you prefer geometry, open the import node's Primitive Definition section and turn on Import Height Fields as Mesh. Alternatively, you can also use a Convert HeightField SOP inside your SOP network.

## Scattering: Solaris - Instance prototype
The next steps creates the prototypes. A prototype is the base geometry that will be instanced. You can use any object, e.g. different rocks or plants. Here, you'll be using a simple Cube LOP. This is just to make things easier to explain.

On the stage, add the Cube LOP and increase its Scale.Y value to `5` to stretch the object along the Y axis. To make the cubes sit on the terrain, enter the following expression to the Translate.Y parameter: `ch("sy")`. When you change Scale.Y, you'll automatically update Translate.Y.

## Scattering: Solaris - Instancing
The introduction pointed out that it is not very economic to do the instancing process in SOPs. The reason is that you might end up with a huge amount of individual objects in Solaris, because the instances will be converted into meshes. If you want to keep your scene manageable, we strongly recommend the workflow presented below. With this technique, you only have one Scene Graph Tree entry for the entire instancing process and one for the terrain geometry. On the right image, however, you can see `35,042` children!

:fig:
    #display: full
    Now you're about to add the centerpiece of the network where you connect scatter points and instance object.

# From the tab menu, lay down an Instancer LOP.
# Connect the instancer's first input (`Input Stage`) with the output of the SOP Import LOP. Then, wire the second input (`Possible Prototype Source`) to the cube's output.
# On the Target Points section, open the Location Source dropdown and choose External SOP. There are several methods available to create or load the scatter points, but here you can access them directly.
# You can now see a SOP Path parameter with a  Open floating operator chooser button. Click it and navigate to the `POINTS` null from the terrain's SOP network. Click it and confirm your selection with Accept.

You can now see the result in the viewport. You might also notice that the `pscale` and `orient` attributes were obviously correctly transferred. To make sure that all attributes exist, go to the Scene Graph Tree and click the `instancer1` entry. On the right side there's the Scene Graph Details pane. Browse the Name and Value columns for `hue` and `saturation`.

## Scattering: Solaris - Material
The material in this example is just an orange color, but its hue and saturation will be driven by the attributes you've written to the scatter points. Note that the material is really just a very basic setup to illustrate the concept. The main idea, however, also works with complex shaders.

# Lay down a Material Library LOP and connect its input with the instancer's output.
# Double-click the library to dive inside and call the Karma Material Builder tool from the tab menu. Again, double-click the new `karmamaterial` node. Inside the material there's a preconfigured shader network.
# Add a MtlX Color Correct VOP and connect its `out` output to the standard surface node's `base_color` input. When you select the color correct node, you can already see the Hue and Saturation parameters.
# Change the Input Color values to `1, 0.5, 0` to get a bright orange color. Below you see an already rendered preview.

## Scattering: Solaris - Reading the attributes
We're still inside the `karmamaterial` node and now you'll connect the points' `hue` and `saturation` attributes with the parameters of the color correct node.

# Lay down a MtlX Geometry Property Value VOP and connect its `out` output with the color correct node's `hue` input.
# For the new node's Geomprop parameters, enter `hue`. Make sure that Signature is Float.
# Add another property value node and connect it to the `saturation` input.
# The entry for Geomprop is `saturation`.
# Also, set Default to `1`. This parameter is a fallback that's used if the attribute from Geomprop is not available. The value corresponds with the default of the color correct node's Saturation parameter.

## Scattering: Solaris - Preview rendering
If you want to improve your scene, you can also add a light source, for example a Dome Light LOP. You can place it between the SOP Import LOP and the Instancer LOP.

To see the result you have to render the scene and for this purpose, Karma offers an "Interactive Preview Rendering" (IPR) system. In the upper right corner of the viewport you can see a dropdown menu with a Persp default entry. Open the menu and choose on the Karma engines.

It'll take a moment for the shader to compile, but then you can see an image similar to what's shown here:

============================================================
# 来源: scattersop.txt
============================================================

## Scattering: SOP
Turn terrains into landscapes.

Scattering is an essential technique that brings your terrains literally to life. Scattering lets you populate a landscape with thousands of objects to make it look realistic. On the Projection page you can already find a basic example that scatters boxes of variable size over a terrain to create mountain chains. The projection scene illustrates the flexibility of the scattering process. This chapter, however, deals with the creation of landscapes, forests, meadows and complete ecosystems.

Scattering is not only good for adding plants and creating forests. You can also use it for decorating the vertical areas of a mountain. Those parts are not considered by heightfield systems for technical reasons. Another idea is to add rocks, stones and gravel to the terrain's ground. Or you cover a riverbed with pebbles.

[TIP]
    The Houdini Labs team is currently working on a world-building system for heightfields. The Biomes system uses rules and mechanisms from Mother Nature to create realistic and controllable environments.

This guide is split into four pages:

* Scattering: SOP illustrates how to prepare your scene.
* Scattering: Removing points shows methods for controlling the number of scatter points.
* Scattering: Attributes creates attributes like `pscale` and `orient`.
* Scattering: Solaris shows how to render your terrain.

## Scattering: SOP - Initial considerations
Before you start to populate your landscape, please take a minute and think about the end of the entire scene creation process: rendering. The reason why it's a good idea to do that at such an early stage is that Houdini provides different strategies for bringing your scene into Solaris.

The perhaps most convenient method is to create all aspects of the scattering process inside the SOP environment where your heightfield lives. Then you can import the entire scene to Solaris and render it with Houdini's Karma engine. As said, it's a convenient way, but it's definitely not the best way. When you think about memory, performance and scene organization, then we recommend to split the workflow. It's therefore important to know what you can (or should) do inside SOPs and what's better done in Solaris.

[NOTE]
    In this example, terrain and points are created on Houdini's obj level. This is - as always - just one method to assemble a scene. Another common way is to use a SOP Create LOP in Solaris to have everything handy on the stage level.

## Scattering: SOP - Scale
Scale is certainly one of most important things to consider with scattering. You should always bear in mind that a default heightfield measures 1000 m by 1000 m. If you're not used to working at such a huge scale, please take care that you don't create oversized trees or rocks. 

It can be a good idea to add reference objects to give you a sense of scale. You can, for example, create objects with different sizes to illustrate the average height of a tree, the diameter of a large rock, or the dimensions of a building.

## Scattering: SOP - Basic setup
This setup requires just a couple of nodes. The guide shows the way from landscape creation to rendering in Karma. You'll also learn why it's (normally) better to do the instancing directly in Solaris instead of SOPs. Let's start with the landscape.

# On Houdini's obj level, press the Tab key to open the Tab menu. From there, choose the HeightField entry to create a preconfigured Geometry OBJ. Double-click the node to dive into it. Inside the node you can see Heightfield SOP.
# Add a Heightfield Noise SOP and connect its first input with the output the heightfield node. This node generates the actual terrain with hills and valleys as shown below.

### Scatter points

Scatter points are like placeholders and define, where the instance objects appear. Scatter points can also carry attributes like `orient` or `pscale` that drive the instances/prototypes. Instancing is the process of copying your objects to the scatter points. The scatter node creates the points that will carry the instance object(s).

* Scatter points are always created in SOP networks and then transferred to Solaris.
* Instancing should be done directly inside Solaris.

To create the node, follow these steps:

# Add a Heightfield Scatter SOP.
# Connect the scatter node's first input to the output of the noise node. 
# Turn on the blue Display/Render flag to see the result.

What you get is a densely covered terrain. The scatter node provides several parameters to get more variation. On the Scattering section you can find a Covering parameter that lets you indirectly control the number of points/instances.
If you want to specify the actual number of points, set Scatter Method to Total Points using Mask Layer. Then set the Total Point Count.

For explanations of the other parameters, please read the HeightField Scatter SOP's help.

### Masking

Masking helps to get rid of a possible uniform look and creates more or less dense areas. You can use a `mask` layer to create points only in those regions that are covered by the mask. The intensities of the mask's colors also determine the density of the point cloud. You can use any masking method provided by Houdini's terrain system. Another method is to create custom masks through VEX scripting.

A fast method to get a naturally looking mask is to use a Heightfield Mask Noise SOP.

# Add the mask node and connect its input with the output of the HeightField Noise SOP that creates the terrain. 
# Link the mask's output to the second input of the scatter node.

When you go to the scatter node's Mask Layer parameter, you can see a  Add a Mask Paint button. Once you've connected a mask layer, this button becomes active. When you click the button, Houdini will add a HeightField Paint SOP and you can paint a custom mask. 

[TIP]
    If you don't want to use a separate mask node, you can also connect the output of the HeightField Noise SOP to the scatter node's second input. Then you have access to the default `mask` layer that comes with the heightfield.

============================================================
# 来源: shallowfields.txt
============================================================

## Shallow Water Solver: Fields
Create mesmerizing effects with the Shallow Water Solver.

[NOTE]
    This guide requires a basic knowledge about heightfields and the Shallow Water Solver. Some of the examples in this chapter are also based on the heightfield and solver settings from the introduction to the Shallow Water Solver to become familiar with fundamental setups and workflows.

When you look at the Shallow Water Solver SOP's Output tab, you can see three parameters that let you store velocity, acceleration and vorticity data as layers. You can use the information for visualizing differences in speed or vorticity, but also for trailing effects. Another field of application is to use fields to drive simulations.

## Shallow Water Solver: Fields - Velocity
Velocity is turned on by default and you can directly map the different velocities to the simulation: From the Visualization dropdown, choose Color Water by Layer. If you already went through the introduction to the Shallow Water Solver, you know that this option adds a turquoise-blue gradient that represents the water's velocities. The Visualization parameters let you control the gradient's color distribution.

For more information, open the Geometry Spreadsheet and click the  Primitives button. There you'll see that there's no combined `velocity` layer, but you have individual `vel.x`, `vel.y` and `vel.z` layers instead. It's also important to know that `vel.y` is always zero, because heightfields are 2D grids without a physical height.

## Shallow Water Solver: Fields - Vorticity
The `vorticity` layer stores the local rotational motion at each point, with larger absolute values indicating faster spinning. Positive vorticity values signal that rotation is in the counter-clockwise direction when viewed from above; negative values indicate a clockwise rotation.

The Shallow Water Solver does not provide any built-in features to visualize vorticity and you need a custom solution.

## Shallow Water Solver: Fields - Acceleration
Acceleration is the rate at which an object's velocity changes over time. It can mean speeding up, slowing down, or changing direction. Like `velcoity`, the `acceleration` layer consists of three components: `accel.x`, `accel.y` and `accel.z`, but again, only the X and Z components are relevant. There's no out-of-the-box feature for displaying this layer and you need a custom solution.

## Shallow Water Solver: Fields - Force
The solver's Binding tab provides an empty Force Mask Layer. You can create a custom, animated mask and connect it to the slot. The solver will use the mask values to push and displace the water.

[TIP]
    There's an example further down that explains how to create a pulsating radial `force` layer.

## Shallow Water Solver: Fields - Visualization: Layers
Houdini's heightfields provide a HeightField Visualize SOP that lets you define custom colors for up to nine layers. A common application with this node is texturing.

The visualize node is typically the last node of your network, because only then you can be sure that all layers will be available. The node's usage is straightforward:

* On the Material section you can see a Height Ramp. The gradient tints the terrain according to the values of the `height` layer. You can click Compute Range to map the entire range of gradient colors to the terrain. When you click the  Presets button, you choose from various predefined color ramps.
* Each of the nine Layer parameters has an associated dropdown menu that list the entire range of existing layers. Choose a layer or type its name to an empty parameter field. Then, define a Color. The layer will be displayed with the chosen color.

[NOTE]
    The layer numbers also indicate how layers are stacked. Imagine the floowing example where assign `vel.x` and `vel.z` to Layer 1 and Layer 2, but `water` to Layer 3. In this scenario, the `water` layer will cover the velocity layer and they're no longer visible. To get a correct result, assing `water` to Layer 1.

## Shallow Water Solver: Fields - Visualization: Trails
You can visualize the information from the solver's layers to create trails with mesmerizing swirling and curling effects. As the name indicates, the node was made to show volumes, but a heightfield is a 2D grid. The Y coordinate is always zero and this is the reason why you will also only see a flat representation.

# Add a Volume Trail SOP to the network and connect its second input with the output of the solver.
# Lay down a Grid SOP and connect its output with fist input of the solver.
# Adjust the grid's Size parameters so that they match the Size values of the HeightField SOP. For example, if the heightfield is 100 m by 100 m, the Size values for both nodes are `100` as well.
# The grid's Rows and Columns parameters define the resolution of the trails. It's not possible to give exact values here, because they depend on several factors.
# On the trail node, go to Velocity Volumes and enter the name of the field you want to visualize. You can also choose an entry from the parameter's associated dropdown menu.
# Then, adjust Trail Length. Longer trails take longer to be drawn and will also create a denser "map".

If the shallow water simulation is cached, you can move the Playbar head or press the  Play button to see the trails in motion.

## Shallow Water Solver: Fields - Creating a force field
Houdini offers a wide range of methods to create custom fields. However, the various techniques have one thing in common if you want to use them with the Shallow Water Solver: The force must be converted into a mask. The following example illustrates how to draw an animated radial mask that pushes the water away from the mask's center.

### Terrain

To get a better view of the force, you should make the terrain smaller. For the HeightField SOP's Size parameters, enter `100, 100`. To get more detail, set Grid Spacing to `0.5` - this will also be the value for the solver's Voxel Size Scale parameter. Most probably you have to decrease the Amplitude and Element Size parameters of the HeightField Noise SOP to get more surface detail.

* You can modify the terrain to your liking, but don't make it too high, because the water should be able to propagate over the landscape.
* You also need a `source` layer to determine where the water will be created. The steps to create this layer are explained on the Shallow Water Solver page.

### VEX script

The idea is to use a VEX script that creates propagating concentric rings and converts them into a mask. Several custom parameters give you full control over the resulting force. To apply a script to a terrain you need a HeightField Wrangle SOP. In your network, place the wrangle directly before the solver and connect its first input.

Then use Ctrl+C to copy the script below and paste it with Ctrl+V to the wrangle's VEXpression field. Click the  Creates spare parameter for each unique call of ch() button to add the custom parameters to the wrangle's parameter set.

    // Parameter section
    vector center = chv("center");       // Custom parameter: Wave center
    float speed = chf("speed");          // Custom parameter: Wave speed
    float frequency = chf("frequency");  // Custom parameter: Wave frequency
    float amplitude = chf("amplitude");  // Custom parameter: Mask strength (= force strength)
    float falloff = chf("falloff");      // Custom parameter: Strength attenuation factor
    float time = @Time;                  // Current simulation time
    
    // Current heightfield position
    vector pos = @P;
    
    // Distance of the current position to the wave center
    float dist = distance(pos, center);
    
    // Wave creation
    float wave = sin(dist * frequency - time * speed);
    
    // Remap wave to a [0,1] range and scale the result with the waves' strength
    float mask = fit(wave, -1, 1, 0, 1) * amplitude;
    
    // Optional: Wave strength decreases with increasing distance from the center
    mask *= exp(-dist * falloff);
    
    // Write the result to the heightfield's @mask layer
    @mask = mask;

### Parameters

The following table gives you an idea what the custom parameters do. The actual values strongly depend on the size of the terrain. The settings below were tested for a terrain size of 100 m by 100 m. To see the effect of your changes, turn on the wrangle's blue Display/Render flag.

table width="100%">>
    th width="15%">>Parameter
    th width="50">>Description

    tr>>
        td>>Center
        td>>Defines the center of the waves. Consider that heightfields are 2D and you'll only need the X and Z values. Place the center near or inside the painted `source` mask. This makes sure that waves can influence the water. You can use positive and negative values. For example, in a 100 m by 100 m terrain, the left edge is at `X = -50`, the lower edge is at `Z = 50`.
    tr>>
        td>>Speed
        td>>The propagation speed of the waves. Start with values between `2` and `5`.
    tr>>
        td>>Frequency
        td>>This parameter defines the number of waves/rings. With smaller values you'll get a denser pattern. Higher settings create thicker rings. Try to stay between `0.2` and `1`.
    tr>>
        td>>Amplitude
        td>>This is the strength of the mask. The mask values are then converted into a force. For this example scene start with values between `1` and `5`. Very high Amplitude values might lead to instabilities.
    tr>>
        td>>Falloff
        td>>You can make the waves fade out with increasing distance from the center. This parameter is very sensitive and you should start with small values around `0.02`.

### Layer creation

The next step is to convert the `mask` into a `force` layer you can use to drive simulation. As with the `source` layer, you also need a HeightField Copy Layer SOP. Place the node between wrangle and solver to connect it and set its Destination to `force`.

A HeightField Mask Clear SOP downstream of the copy node resets the circle mask. For Layer 1, enter `mask`.

### Solver adjustments

You also need some adjustments on the solver. While most parameters on the Setup tab strongly depend on the shape and size of your terrain, there are a few settings you must consider:

* On the Setup tab, go to the Constraint Updates section. From the Forces Frequency dropdown menu, choose Every Substep. This option will apply the values of the `force` layer with every simulation substep. You can also apply the force at every frame, but substeps tend to create a smoother result - even if this method takes longer to simulate.
* On the Bindings tab, go to Force Mask Layer and enter `force` to establish a connection between the solver and the new layer.

On the Simulation tab, adjust Voxel Size Scale. For this example with a 100 m by 100 m terrain, a value of `0.5` was used, but you might want to enter a different value. Also on the Simulation tab, you can increase Cache Memory (MB) to cache the result to your computer's RAM for fast playback.

When you simulate, you should see how the force pushes the water and creates bow-shaped waves as in the time-lapse video below.

:video:
    #src: /videos/heightfields_radforce.mp4
    #loop: true

============================================================
# 来源: shallowintro.txt
============================================================

## Shallow Water Solver: Introduction
Flooding heightfields.

Imagine a situation where you need a fast method to create large amounts of water. A particle-based fluid simulation is perhaps computationally too expensive, and an ocean surface is most probably not flexible enough. This is a typical scenario for Houdini's Shallow Water Solver, because it fills the gap between highly-detailed simulations and ocean spectra representing a water surface. The Shallow Water Solver is capable of simulating flowing water and ýou can create:

* ripples and non-breaking waves
* ponds and puddles
* water running over cracks and surface irregularities
* stylized water or water surfaces in distant areas
* fast flooding of large areas
* streams and trickles

You can consider the Shallow Water Solver as an extension for Houdini's heightfields. From a technical perspective, a heightfield is a 2D grid with height (or other) information stored at its grid points as a so-called layer. The `height` layer is one of the principle layers with heightfield. Typical layers with heightfields are `sediment`, `flow` or `debris`. These types of layers shape the terrain, for example by removing or adding material. In fact you're manipulating the terrain's height information to achieve a certain look. The Shallow Water Solver works according to same principle and adds a `water` layer to the terrain.

Aside from `height`, there's also a principle `mask` layer. A mask limits an effect to a user-defined area. Houdini's heightfields provide a wide range of nodes to draw masks, calculate them from the terrain's topology or an object's volume. Masks are an essential concept in conjunction with the Shallow Water Solver, as they define where water is sourced or drained.

## Shallow Water Solver: Introduction - Limitations
You can use the solver for large-scale simulations, but also for small-scale effects as listed above. The solver is very fast, but often suffers from stability problems, especially at high resolutions or high propagation speeds. This is typically manifested in jitter, spikes or disappearing heightfield voxels.

* The solver can't simulate secondary water effects like splashes or spray.
* Breaking waves are not possible.

## Shallow Water Solver: Introduction - Heightfield setup
You need a heightfield to make the Shallow Water Solver work. You can read more about such a basic scene on the heightfields page. Here, you'll only get the fundamental explanations to get you started.

# On the obj level, press Tab to open the tab menu. There, enter `hf` and choose HeightField to create a new Geometry OBJ. Double-click the geometry node to get access to the HeightField SOP inside. In the viewport, you can see a flat plane representing the heightfield grid with empty `height` and `mask` layers.
# To get more surface detail, decrease Grid Size to `1`. Note that this value is also relevant for the solver.
# Add a HeightField Noise SOP and connect its first input with the output of the heightfield grid. This nodes adds height information and creates a landscape with mountains and valleys.

### Shaping the terrain

The terrain's topology has strong influence on the behavior of the water. However, scenes with extreme height differences might not look good in the end. Here you'll be working with a relative flat landscape. On the HeightField Noise SOP, set Amplitude to `200` to create smooth hills. Also, increase Element Size to `600`. This parameter changes the scale of the fractal pattern and with higher values, you can reduce the amount of peaks.

You can also make the seabed more interesting by adding more surface structures. A good way to do this is to add a HeightField Distort by Noise SOP. Connect its first input with the output of the upstream noise node. Then, set Amplitude to `20`. This parameter controls the strength of the curl noise that deforms the terrain.

## Shallow Water Solver: Introduction - Sources
The Shallow Water Solver requires a `source` layer to define where the water originates - and the `source` is essentially a mask. We recommend that you read the heightfield guide's Masking pages. There you'll get a comprehensive overview how to create, combine and manipulate masks. On the VEX scripts for heightfields page you can also find several methods to create custom masks with scripting, for example rings or ovals.

[NOTE]
    You can also make the water disappear through a sink.

# Lay down a HeightField Paint SOP and connect its input with the output of the distort node.
# The most interesting parameter on the paint node is FG Value, because it controls how much water will be sourced. With values greater than `1`, you can create more water per unit time. For this project, enter a value of `0.5`. 

    A value of `1` is the base amount of water being sourced. A value `0.5` will only source 50% of the base amount, and with `2` the amount will be doubled.

# Hover the mouse over the viewport and press 2 to switch to top view. Then, press Enter to turn on the draw mode. A red sphere indicates the size of the paintbrush. Use the mouse_wheel to change the size of the brush.
# With LMB pressed, draw over the terrain. The viewport grid will help you to identify deeper areas of the landscape. Draw a pattern that looks similar to the image below.
# Press ESC to leave the draw mode.

### Refining the mask

Right now, the mask is just a red area without structure. To make things more interesting, you can add a HeightField Mask Noise SOP and connect its first input with output of the paint node. The node creates a mask with spots of different size and "opacity".

When you set Combine Method to Subtract, everything outside the painted area will be removed and you also create spots inside the painted area. With Amplitude you can directly influence the amount of water being sourced. Set it to `0.5` to get more variation. Element Size changes the size of the red spots. With `100` you can break the pattern, because the spots become smaller. 

### Creating a source layer

So far, you've only worked on the `mask` layer. To convert the `mask` into a `source` layer you need a HeightField Copy Layer SOP. Connect the node's input with the output of the noise mask. Then, go to the copy node's parameter set. For Destination, enter `source`. Now you've transferred the information to a new layer that can be evaluated by the Shallow Water Solver to create water in the red areas.

It also makes sense to reset the `mask` layer with a HeightField Mask Clear SOP. Add it to the network and set `Layer1` to `mask`. This node does not delete the `mask` layer, but sets all values to zero instead.

## Shallow Water Solver: Introduction - The solver
You've got everything you need to flood the terrain with water and you can lay down a Shallow Water Solver SOP. Connect its first input with the output of the last upstream node. It's often a good idea to perform a simulation with the default values to see what you might want to change.

The most obvious observation is perhaps that the water is hardly visible and it's therefore difficult to evaluate the results. To change this, open the solver's Output tab. From the Visualization dropdown menu, choose Color by Water Layer. You can now see blue strings on a turquoise area. 

The water also immediately starts to fill the basin, but it's very shallow. Another issue is that the water hardly propagates over the terrain.

### Resolution

On the Simulation tab, you can find a Voxel Size Scale parameter that corresponds with the heightfield's Grid Spacing. A convenient workflow is to use the same value for both parameters. If you decide to work with different values, note that the solver's parameter overrides the terrain's value.

High-resolution terrains/simulations can also lead to instabilities. The resolution, however, strongly depends on the terrain's size. With large areas, you normally work with values between `0.5` and `2`. A small terrain, for example with a size of 20 m by 20 m, requires values around `0.025` or less to get enough detail.

If the fluid simulation suffers from stability problems that can't be resolved with damping and velocity limits, consider increasing Voxel Size Scale.

### Source scale

Increasing Source Scale is an effective method to get more water. The parameter is a multiplier for the values in the `source` layer. If you apply a high value of `100`, you'll get a massive initial water volume. The top of the volume also shows an irregular structure. The reason is that the terrain is considered here, because the mask is semi-transparent. With a completely opaque mask, the top would be even.

If you don't want a mountain-like water volume as the simulation's initial state, you can animate the parameter. Let's assume you want to start sourcing at frame 0 and have full "power" at frame 100.

# On the Playbar, drag the playhead to frame `1`.
# Set Source Scale to `0 ` and Alt+LMB-click the parameter to create an animation key.
# Move the playhead to frame `100`.
# Increase Source Scale to `15` and create another key.

On the solver, press Reset Simulation to start a new pass. Now, the water rises slowly, but it has edges and the structure of a lava field.

### Time scale

You can use the Time Scale parameter on the Source tab to control the water's propagation speed. The terrain is quite large and a scale of `5` appears appropriate. You might have noticed some instabilities as well. Before you start to increase the number of simulations steps on the Simulation tab, always try to stabilize the simulation with the parameters of the Setup tab. An effective method is to add moderate viscosity to the fluid by setting Velocity Diffusion to `0.3`.

### Speed limits and damping

Another, even better way, uses the parameters of the Speed Limits section. Turn on Max Wave Speed and set its value to `2`. This will clamp all waves with higher velocities to this value. You will see that the overall behavior is much better now and that you can really flood the terrain with water.

You should also consider to introduce a Damping Layer, because it'll improve the quality of the simulation near the borders. Turn on Enable Damping Layer and increase Layer Size to `30`. This parameter helps to make waves disappear at the borders. If this parameter is not high enough, you might see waves being reflected at the borders and rolling back into the water. For a large terrain, a value between `20` and `50` is often enough. The four Axis toggles let you decide which borders should be affected by the damping layer. In most cases you'll be using the default choice.

## Shallow Water Solver: Introduction - Sinks
If you want to make the water disappear, you can create a `sink` layer. Like its `source` counterpart, this layer also originates from a mask. You can use the same nodes and techniques for the creation of `source` and `sink` layers. However, a sink can't work without a source.

## Shallow Water Solver: Introduction - The water layer
The `water` layer you get from a simulation is part of the heightfield. The Shallow Water Solver differentiates between absolute and relative `water` layer values. To change between the modes, go to the Output tab. When Output Water Height is Absolute is:

* turned on, `water` contains the location of the water surface
* turned off, `water` contains the height of the water column at each voxel

When you turn on Output Terrain Includes Water Height, the Water Layer is added to the Seabed Layer. In the viewport, the water appears elevated from the underlying collision surface. When you turn it off, the water appears as a thin colored film over the collision geometry. This mode can be interesting if you want to create a wetting effect.

============================================================
# 来源: shallowoutput.txt
============================================================

## Shallow Water Solver: Outputs
Save and convert shallow water simulations.

On the previous pages, it was mentioned several times that the results of the solver are available as layers, for example `water`, `vel.*` or `force`. In many cases you will use the layers directly for texturing and rendering. In this context, the layers will again act as masks to spare out certain areas and reveal underlying structures. You can read more on the Texture basics and Texture layers pages of this guide.

## Shallow Water Solver: Outputs - Conversion
If you convert your heightfields to polygons and points, all layer information will be automatically translated into appropriate point attributes. The node for this process is the Convert Heightfield SOP and you must add it downstream of the Shallow Water Solver SOP.

## Shallow Water Solver: Outputs - Caching
When you start a simulation, the result will be cached to the computer's RAM. With large high-resolution heightfields, the default cache of 5000 MB is normally not enough to cache more than 150-200 frames. On the solver's Simulation tab you can adjust the allocated memory with Cache Memory (MB).

If you want to cache a simulation to disk, you can add a File Cache SOP. This node lets you assemble a file path and adjust a frame range. Versioning is also supported. Please read the File Cache SOP's help page for more information on the parameters.

Once you've made your settings, you can press one of the Save to ... buttons to write a sequence of files to the specified directory. Make sure that Caching > Sequence > Simulation is turned on! When you turn on Load from Disk, you can replay the simulation in Houdini.

## Shallow Water Solver: Outputs - Geometry extraction
If you only need the geometry of the water surface, you can do that with a single Blast SOP from the converted heightfield.

* Add the Blast SOP and connect its input to the output of the convert node.
* Set Group Type to Points.
* On the Group parameter, enter `@water==0`.

The node will now delete all points with a `water` value that is not 0 and you'll get the water surface with UV coordinates. If you don't want to delete any points, but store the `water` points in a group, you can do that with the same expression.

* Instead of a Blast SOP, lay down a Group SOP and connect it.
* For Group Name enter `water`.
* On the Base Group section, go to Base Group and enter `@water>0`.

Both methods also work with any other layer like `vel_x`, `accel_z` or `vorticity`. Note that you have to turn on the `acceleration` and `vorticity` layers on the solver before you can turn them into groups or delete them.

============================================================
# 来源: shallowtrouble.txt
============================================================

## Shallow Water Solver: Optimization
Configure and optimize shallow water simulations.

The Shallow Water Solver provides various parameters and options to control the simulation, fix errors, and customize a simulation.

:task: Improve the simulation's overall quality

    * Shallow Water Solver simulations are based on substeps. If you see instabilities, open the Simulation tab, and increase Substeps. Higher values slow down the simulation, but create more accurate results. You can increase the parameter in steps of `10`.

:task: Avoid reflecting waves

    * By default, waves are reflected at the heightfield's boundaries. The fastest way to avoid reflections is to open the Setup tab, and change Boundaries to Periodic. Waves will then pass through the heightfield's boundaries, but reappear on the opposite side.
    * You can also dampen waves near the boundaries with parameters in the Damping Layer folder. This works for all types of Boundaries.
        # Turn on Enable Damping Layer.
        # The axis checkboxes let you choose in which directions the waves should be damped.
        # Large Layer Size and Damping Strength values help to damp the waves before they reach the boundaries.

:task: Avoid repeating and reentering waves

    * Open the solver's Setup tab and change Boundaries to Reflective. Waves will now be reflected at the heighfield's boundaries.

:task: Make the water faster

    NOTE:
        Note that fast moving water may causes instabilities. To fix this, go to the Simulation tab and increase Substeps in increments of `10`.

    * If you are utilizing sourcing, you can go to the Setup tab and increase Source Scale. This change sources more water and makes it flow faster.
    * Another way is to increase the Setup tab's Gravity parameter. You can, for example, enter an expression like `9.8*2` to double the value.
    * With values greater than `1`, Time Scale speeds up the entire simulation, resulting in more flow per frame.

:task: Make the water slower

    * If sourcing, go to the Setup tab and decrease Source Scale to get a smaller water volume.
    * Also under Setup, decrease Gravity, for example with an expression like `9.8*0.25`.
    * With values, smaller than `1`, Time Scale slows down the entire simulation, resulting in lower flow speed.
    * In the Setup tab, turn on Max Wave Speed to set a speed limit for the waves.

:task: Source more water

    * You can draw a bigger `source` mask. Instructions on how to draw such a mask can be found on the Shallow Water Solver page.
    * In the solver's Setup tab, set a higher value for Source Scale.

:task: Use Velocity Diffusion

    * This parameter blurs the velocity field and with higher settings, the water becomes more viscous.
    * Small values of Velocity Diffusion can also help to stabilize the simulation.

:task: Use a force mask

    All mask layers are located in the solver's Bindings tab. Force Mask Layer is not preconfigured, but the workflow is the same as with the other layers. Below, there's a quick guide. For a more complete workflow, visit the Shallow Water Solver fields page.

    # Create a heightfield mask node, e.g. using HeightField Paint somewhere in your network between the Heightfield and the Shallow Water Solver node.
    # Create the mask.
    # Add a HeightField Copy Layer node.
    # Under Destination add a unique name, e.g. `force`. Don't use any of the names, listed in the solver's Bindings tab.
    # Add a HeightField Mask Clear node to delete the current `mask` and keep the network healthy.
    # Go to the solver's Bindings tab. Under Force Mask Layer, enter `force`.
    # On the solver's Setup tab, set Forces Frequency to Every Frame or Every Substep.

:task: Use animated masks

    Masks don't have to be static. You can, for example, use an animated HeightField Noise or a deforming object to create a source mask.

    * In the solver's Setup, go to the Constraint Updates subpane.
    * Set Source Frequency to Once per Frame to signal the solver that the mask is animated. For an animated sink mask, use Sink Frequency.
    * If the mask's animation or deformation is very fast, choose Every Substep to increase precision. Note that this option can drastically slow down the simulation.
    * You can also use a static mask, but animate Source Scale instead.
    # Move the timeline slider to the frame, when sourcing should start.
    # Alt+LMB click the Source Scale parameter to create an animation key.
    # Go to the frame when sourcing should be at maximum.
    # Create another key.

:task: Change mask and layer names

    You can change the layer names under the solver's Bindings tab. 

    # Enter a new name for the layer you want to change. Make sure that every name is unique and not used anywhere else in the network.
    # Update all nodes where the original name occured and apply the new layer name.

:task: Avoid spikes and disappearing voxels

    Sometimes you might see spikes or disappearing voxels. This often happens with fast moving water, or in areas where water with different flow directions collides. Below you can find ways to reduce the spikiness.

    * Go to the solver's Simulation tab and increase Substeps. A good start is to double the default value to `20`. You can also try higher values of `50` or even `100`.
    * Under the Setup tab you can find Velocity Diffusion. Very small values (< `0.001`) help to stabilize the simulation. Very high settings make the water more viscous.
    * In the Setup tab there's the Max Wave Speed checkbox. Turn it on and enter a hard speed limit. This can also help to reduce the occurrence of spikes.

============================================================
# 来源: slump.txt
============================================================

## Slump
When mountains crumble to rocks.

When loose stones and rocks become unstable, they slide down for a rather short distance and form out deposits in lower areas. The HeightField Slump SOP lets you simulate and fine-tune this process through a wide range of parameters and masks.

The node also provides two different modes for creating slump: Smooth and Granular. Both modes have different parameter sets, while Granular also supports a simplified, yet powerful erosion model without simulation. Slump in conjunction with granular erosion creates very realistic results with valleys that are filled with debris.

Angles play an important role with slump and erosion in general. The node's Repose Angle, for example, determines the angle at which the loose material remains stable. With `70`, loose material will remain stuck only in very steep areas. When you set Repose Angle to `40`, for example, you will also get slump deposits in less step parts.

## Slump - Example: Eroded hillsides
This example network creates eroded hillsides with debris, depositing in the valleys. Start with the adjustment of the HeightField Noise SOP.

[NOTE]
    The following example uses the base setup from the introduction, consisting of a HeightField SOP and a HeightField Noise SOP.

# Set Amplitude to `1000` to get very high mountains.
# To compensate for the extreme height, increase Element Size to `800`. The parameter scales the noise and removes high-frequency spikes.
# Change Offset.X to `390` and move the noise pattern along the positive X axis to see a different part of the noise pattern.
# On the Noise Settings section, set Noise Type to Worley Cellular F1.

A HeightField Distort by Noise SOP breaks the edges and ridges, and creates the typical look of rough and weathered rock. Set the node's Amplitude to `15`.

And here's what you get with the above settings and values.

### Slope mask

With heightfields, things often look better when you apply masks to restrict an effect to certain areas of the terrain. Slump is no exception.

# Lay down a HeightField Mask by Feature SOP and connect its input with the output of the upstream HeightField Distort SOP.
    
    By default, the Slope method is turned on and you'll be going to use this feature.

# Change Min Slope Angle to `5` and Max Slope Angle to `50`. The red areas indicate where the slump material will be added.
# The mask appears a bit aliased and to blur it, increase Smooth Radius to a value between `1.5` and `2`.  

### Slump

We want the sediment to fill the valleys and the space between the erosion channels in steeper areas of the terrain.

Add a HeightField Slump SOP and connect its input to the output of the mask node. When you connect the node and turn on its blue Display/Render flag, you'll immediately see an effect. The masked areas are now smooth, because they contain all the fine sediment that came down from the mountainside.

# On the Slump tab, change Slump Mode to Granular and you'll get loose material filling parts of the terrain. The look, however, is pretty noisy and it seems as if rocks were sliding downhill.
# To get rid of the noisy look, play with  the Quantization parameter. The value basically defines the sediment's granularity. For example, with a value of `0.1`, the material becomes a smooth and amorphous mass without surface structures. Higher values like `1`, however, add more detail to the sediment. There's often a kind of "threshold" where the structures start to look unnatural. So, please be cautious with very high values.
# You can also break the smooth area by setting a Repose Angle. This parameter describes the steepest angle at which a granular material can be piled on a horizontal surface without sliding. Try a value of `30`.

==== Erosion ====

To get the nice look with the erosion channels, turn on Do Erosion. Note that this mode is only available with the Granular mode.

When you turn on erosion, the heightfield disappears and the node shows an error, because it lacks two fundamental things from the Layer Bindings tab: Entrained Material (see Entrainment below) and Sediment. Without these layers, erosion won't work. The layer for Entrained Material defines areas with already loose material and those areas won't be considered during the slump-creation process.

Here, you'll be using `mask` for both bindings. What you get now is a mountain range with lots of deep grooves that cover then entire terrain.

# Go back to the Slump tab and change Global Erosion Rate to `0.6`. This value depends on Spread Iteration and with every iteration, you'll remove material.
# Erodability defines the rock's softness. Higher values are good for the creation of rather soft types of rock like limestone or dolomite. If the rock consists of minerals like feldspar or quartz, e.g. in granite, it'll become harder. Here, we're going to assume a rock of medium hardness and decrease the parameter's value to `0.7`.

You can leave the remaining parameters, esp. those from the Advance Erosion tab, untouched. Many of them are only required for the creation of riverbeds. However, for the image below, Removal Rate is `0.5`.

Now, the slump/debris fills the erosion channels and you get the typical look of highly eroded mountains with lots of slump that accumulated in deeper areas.

[TIP]
    If you network already contains an upstream HeightField Erode SOP, you can use its `debris` and `sediment` layers as input layers for the slump node's Entrained Material and Sediment.

==== Entrainment ==== (entrainment)

Entrainment sounds abstract, but fortunately it's not difficult to understand.

Imagine a glacier, flowing down a mountain. On its way, the ice drags rocks and stones from the underlying bedrock and carries them downstream. In geology, this transportation process is called entrainment. When you measure the amount of rock that's taken with the ice, you get the glacier's entrainment rate. The same applies to gravel in rivers or material that's washed out from steep slopes.

With Slump Mode set to Smooth, you can determine the Entrainment Rate. This controls the percentage of the entrained material that is dragged with the slumping material in each iteration. In other words: higher settings will make more material flow down with the slump material.

## Slump - Flow Field tab
On the HeightField Slump SOP you can find a Flow Field tab that lets you choose whether you want to Calculate Flow Fields or not.  When you leave the option turned on, the node creates two layers. You can find the `flow` and `flowdir` output layers on the Layer Bindings tab.

The slump node's flow fields are a basic form of the HeightField Flow Field SOP. On the flow field node's help card you can find the following information about the `flow` and `flowdir` output layers.

* The `flow` layers represent the cumulative material flow. This layer has two signed components (X and Y) representing the flow direction in voxel space. Because this is cumulative, if material flows left, then flows right, those two motions will cancel and the X component would be 0.
* The `flowdir` layer contains vectors for the XYZ directions, showing the average direction of flow at each voxel. This is converted from voxel space into geometry space. Note it does not include any change in height.

============================================================
# 来源: terracing.txt
============================================================

## Terracing
Step by step closer to the top.

In nature, rocks from lower layers are compressed through overlaying layers and therefore harder. The softer upper layers are eroded faster and create terraces. Terraces also indicate geological formations and the layers are often differently colored. The layers can also consist of different types of rock. A typical combination contains layers of sandstone, interrupted by clay. The type of material depends on the environmental conditions at the time of creation. Sandstone is often created under dry and arid conditions, while clay indicates humid periods with more precipitation. Limestone and slate, on the other hand, are marine sediments.

You can find terraces at cliffs, slopes, mountains, riverbanks, quarries, canyons or landslides. However, these structures don't have to be huge and terraces also occur in relatively small areas like the banks of a creek. To sum up, one can say that terraces are a good method to enhance your terrain's overall appearance and mimic geological structures.

Out of the box, Houdini's terraces often look artificial, because they have hard edges. That's why terraces are typically combined with other nodes and masks to give them a natural look. Even for man-made structures like the famous rice terraces in South Asia, it makes sense to add a slight amount of blurring or some mild erosion.

Houdini's terraces are always horizontally aligned and there's no default method for changing their orientation. The terraces' height is also fixed and you need custom solutions to art-direct this feature. However, there are already many built-on functions to work on terraces.

## Terracing - Adding terraces
The node for creating terraces is the HeightField Terraces SOP. You can add this node anywhere inside your network, but you need at least a terrain, e.g. a HeightField Noise SOP. It's also possible to use multiple terrace nodes with different masks and parameters.

By default, the node creates terraces between a height of 10 and 100 meters. This is the masked area and displayed as a red band on your terrain. To modify this band, change the HeightField Terrace SOP's Min Height and Max Height parameters. If you're not sure about working values, click Compute Range.

With Fade you can blend terrain and terraces. A value of `0` means that you can see the pure terraces, while `1` will only show the original terrain. When you expand the Terracing section, you will also a see Fade Ramp. This ramp lets you control where you want to see more or less terraces. You should also consider using Smooth Edges for a softer look.

With Max Step Size you control the maximum height of the terraces in meters. As with Fade, you can apply a custom curves to get terraces of different height. However, there's no parameter that lets you directly create terraces with random height values. This would only be possible through a custom solution.

## Terracing - Mesa and cliffs
The HeightField Terrace SOP writes out two layers called `mesa` and `cliffs`. You can find both layers in the Output Layers section. The first layer (`mesa`) contains the horizontally clipped areas of the terraces. The second layer (`cliffs`) represents the vertical parts. Both layers are also masks and you can reuse them, e.g. if you want to scatter rocks and plants only in specific areas.

There are also three slope-based parameters that let you refine `mesa` and `cliffs`. However, the impact of the parameters is not always visible. For a better view, you can isolate the layers and adjust the parameters.

# Add an HeightField Isolate Layer SOP and connect its input with the output of the HeightField Terrace SOP.
# Turn on the isolate node's blue Display/Render flag.
# Go to Layer to Isolate and replace the default entry with `cliffs` or, depending on which layer you want to display, `mesa`. You will now see the 2D projection of the chosen layer.
# Select the upstream terrace node and change the slope parameters. Note that Mesa Max Slope only works on the `mesa` layer, while Cliff Min Slope is exclusive to `cliffs`.

You can also change the terrace node's other parameters like Min Height or Fade, and observe how your changes affect the layer masks. This often gives you a better impression of what the parameters do.

## Terracing - Example: Inclined terraces
In nature, terraces are often horizontally aligned and the layers are stacked like the pages of a book. However, sometimes you can see inclined or folded layers, esp. in so-called folded mountains like the Alps. There, the African continental plate pushes against the European plate. Tectonic forces push the plates together and fold them. As a result, the rock is squeezed and deformed like layers of caramel.

Just on a side note: Another consequence of this continental motion is that the Mediterranean Sea will disappear some day.

The HeightField Terrace node doesn't provide any methods to create folded terraces and you need a trick. Basically, the idea is to deform only the terraces through a pattern and reapply them to the terrain.

### Distortion pattern

[NOTE]
    As in the heightfield guide's other examples, this setup also starts with the basic network consisting of a HeightField SOP and a downstream HeightField Noise SOP.

You need a pattern to deform the terraces. The base of this pattern is a customizable ramp or curve to create bulges, folds, or a certain degree of inclination. You can also mix multiple patterns to create complex shapes.

# Add a HeightField Pattern SOP. Connect the HeightField Noise SOP's output with the first input of the pattern node. Now the base heightfield has to connections: noise and pattern.
# Turn on the pattern node's blue Display/Render flag to see the result of your actions.
# The default pattern is Stars. To change this, go to the Pattern section's Pattern dropdown menu and choose Ramp. You'll now see a saw tooth deformation.
# The Ramp Remapping graph lets you define a custom curve or choose one from the  Presets menu. Choose Hill to get wave pattern.
# On the Position tab, increase Size to `600`. This is the size of the base terrain and creates several peaks that stretch over the heightfield.
# If you want to control where the hills and valleys appear, change Phase. With `0.5`, for example, you shift the wave by 50% of the heightfield's length. That's 500 meter, also known as the terrain's midpoint.

If you want, you can modify the curve, e.g. by adding extra control points, or maybe you want to try out one of the other presets.

### Subtract heightfields

You have two separate heightfields now: noise and pattern. To combine them, lay down a HeightField Layer SOP. Connect the first input with the output of the noise node. Link the second input to the output of the pattern node (Terrain to Layer). Since both heightfield share the same layers (`height` and `mask`), the terrains are seamlessly merged.

You will also notice that the entire heightfield is bulged now, because the layer node's Layer Mode is set to Add. The idea here is to subtract the layers, apply the terraces, and then *add* the curve again. As a result, only the terraces will be distorted and bulged.

* Set Layer Mode to Subtract.

### Terracing

Time to add the terraces. The only changes here concern the Min Height and Max Height parameters to shift the terraces away from the mountain tops towards the ground, and Max Step Size.

# Lay down a HeightField Terrace SOP and connect its first input with the output of the layer node.
# Change Min Height to `-80` and Max Height to `-40`. The range, where terraces occur is 40 meters.
# To get more, but thinner layers of rock, decrease Max Step Size to `8`.

The terraces appears as a red band and you can also apply a mask to restrict the terraces to certain areas.

### Add heightfields

In this step you'll merge the current terrain with the terraces and the pattern by adding both. This way you restore the terrain's original shape from the HeightField Noise and only the terraces will follow the wave pattern.

# Add another HeightField Layer SOP.
# Connect its first input with the output of the terrace node. Then link the second input_ to the output of the pattern node.

Since the default Layer node is already Add, you will immediately see the result of the merge. If you want a weaker distortion, go to the pattern node's Height parameter and decrease it, e.g. to `75`.

Of course, you can also experiment with different patterns, masks, and everything else Houdini's toolbox has to offer. To get a linear inclination, for example, choose Linear or Smooth from the pattern node's curve presets. With Height you can control the amount of inclination.

To get rid of the mask, you can add a HeightField Mask Clear SOP and terminate the network.

Here's an example of what you can get with this method.

============================================================
# 来源: texturebasics.txt
============================================================

## Texture basics
Bring terrains to life with colors.

Adding textures to huge terrains can be challenging, because it's not so easy to find working texture maps. In many cases you'll combine different maps and apply techniques like hex-tiling or tri-planar mapping to avoid seams and repitive patterns.

But, there's another methods that's fully procedural and doesn't even require UV coordinates: colors. The advantage with this method is that you don't have worry about maps if you want to change the appearance of your terrain. Instead you change color definitions and mask layers. This approach can work well for distant mountains, but also small terrains. In the latter case you can add different colors to the ground to give it a certain appearance like soil. Then, you scatter plants and debris over the ground.

## Texture basics - Colors
The heightfield layer system lets you combine different masks to carve out even finest details. You can add, subtract or multiply layers from various nodes, create masks from slope or curvature, and colorize each feature separately. This process even works without texture coordinates. And, to render the terrain, you can convert the terrain and bake the colors directly to the mesh as a `Cd` attribute. Then, Houdini will also add a `uv` attribute to store the texture coordinates.

Create a base terrain to your liking. The mountain range from the images uses a HeightField Noise SOP with a Worley Cellulars F1 noise and some distortion.

## Texture basics - Slope
Let's start with a custom `slope` layer and combine it with a noise mask to break its regular appearance. For the `slope` layer, lay down a HeightField Mask by Feature SOP and make it the last node of your current network. You don't have to change anything, because the Mask by Slope option is turned on by default and the standard values give pretty good results already.

A HeightField Mask Noise SOP will create an irregular pattern. The question is now, where to connect the upstream nodes? Should the feature mask go the the noise mask's first or second input? This question is relevant, because it'll create completely different results. When you connect the feature mask to the

* first input, you can profit from the noise mask's Combine Method
* second input, the noise mask will only be created in the areas of the feature mask.

Here, the two masks should stretch over the entire terrain and therefore, you need the first input. Once you've connected the nodes, decrease Element Size and set Combine Method to Difference. This mode subtracts the masks and creates large areas, but also spots of varying intensity.

To prevent the current mask from being overridden by new downstream layers, you copy the mask and apply a new name to save it as a separate layer.

# Add a Heightfield Copy Layer SOP and connect it to the last upstream node.
# For Destination, enter `slope`.

Click the Node info button from the copy layer node's radial menu to see the newly created `slope` layer.

When you follow the create-copy principle, you can create and isolate many more layers to see different structures. You can, for example, mask the mountains' ridges or occluded areas, but also custom masks with VEX scripting are possible. The list is almost endless.

## Texture basics - Erosion layers
Erosion is something you should always add to a terrain - or at least most of the time. Erosion brings the various terrain features together and creates a realistic look. When you connect an HeightField Erosion SOP, you'll get instantly four more layers: `debris`, `sediment`, `flow` and `flowdirection`. You can see them on the erosion node's Layer Bindings tab.

The layers are directly created and appropriately named by the node itself, so you don't have to prevent them from being overridden. However, if you want to add another HeightField Erode SOP and want to preserve the original layers, you should copy them.

## Texture basics - Visualization
The HeightField Visualize SOP lets you apply colors to your layers to make the different features of the terrain visible. The color palette defines the type of rock. Reddish and beige colors indicate sandstone, grayish and blue colors can stand for granite, while brown colors are often visible with iron-bearing rocks. You can, of course, add multiple visualize nodes to create variants with different colors. Colors will give your terrain a certain impression and this way you can create a desert, a grassland or a flat rocky plain with ponds and creeks.

By default, the HeightField Visualize SOP applies the color gradient from the Height Ramp to visualize the height values. With Min Elevation and Max Elevation you can map the colors onto the terrain. Before you start to adjust the elevation values, we recommend clicking Compute Range to get an idea of the maximum and minimum values.

The node provides nine slots for your layers. You can choose a layer from the dropdown menu that's associated with each parameter, or you can also enter the name directly. Then, define a color for each layer. The Layer # parameters also let you override the Height Ramp gradient when enter `height` to one of the slots. Instead of gradient you'll get a single color.

## Texture basics - Conversion
Before you can bring your terrain to Solaris and render it with Karma, you have to convert it and bake the colors. The Solaris SOP import nodes are capable of converting heightfields on the fly, but only without colors.

# Add a Convert HeightField SOP and connect its input with the output of the layer clear node.
# Turn on Bake Point Colors to add a `Cd` attribute to each point that can be rendered in Karma. In Solaris/USD, the `Cd` attribute is renamed to `displayColor`.

For the sake of simplicity, the Solaris import is done through a single node. The example networks don't contain any nodes that require special treatment in Solaris.

On the stage level of the Network Editor, press Tab to open the tab menu and choose Scene Import (All). This tool is a preconfigured version of the Scene Import LOP. The importer takes what it finds on the SOP level and displays it in the viewport, but respects the SOP nodes' blue Display/Render flags. You can also use the SOP Import LOP if you want import only a particular SOP node.

## Texture basics - Copernicus
Houdini's Copernicus image processing framework provides many features you can use for texturing heightfields. Here are some helpful resources.

::Heighfield Manipulation
::Heightfield Textures
::Texture Synthesis

============================================================
# 来源: texturelayers.txt
============================================================

## Texture layers
Stack textures with layers and masks.

Layers are a very good way to visualize certain features like snow, water or certain types of rock. A layer is basically a mask that was copied and stored separately for reuse. You can also use them to break regular patterns and repetitions. Houdini's heightfields write out a wide range of layers such as debris, flow, sediment, water, bedrock and others. And you can also create an almost infinite number of custom layers and masks.

On the Texture basics page you've learned how to visualize terrain structures through colors and various layers. This chapter explains how to bring the various layers to Solaris and Karma for texturing.

[NOTE]
    For better visibility and to simplify the descriptions, the following guide uses colors instead of real textures.

## Texture layers - SOP setup
You can use any terrain, but please make sure to have at least two layers. A good source for layers is the HeightField Erode SOP. Here you get `debris`, `sediment`, and `flow` layers, but you can also create custom masks.

Houdini's heightfields are volumetric fields, but the Solaris framework expects polygons. You therefore have to convert the terrain. One method is to use a Convert HeightField SOP. Another way requires a SOP Import LOP on the stage (see "LOP setup" directly below).

## Texture layers - LOP setup
You need the above mentioned SOP Import LOP to bring the heightfield into Solaris. Next to the SOP Path parameter, click the  Open floating operator chooser. Use the panel's tree representation to navigate to the last node of heightfield SOP network - typically a Null SOP.

If you don't want to convert the terrain before the import, open the import node's Primitive Definition. There, turn on Import HeightFields as Mesh option. You also need a material. Follow these steps to create and apply a shader.

# Lay down a Material Library LOP and connect its input with the SOP Import LOP's output.
# Double-click the library to dive inside. Press Tab to open the tab menu and choose Karma Material Builder. This tool adds a subnetwork and inside the node you can find a basic shader setup.

The centerpiece is the MtlX Standard Surface VOP. This shader node provides a wide range of categories that finally define the look of a material. When you expand a category, you can see its associated parameters. For the following example, expand the Base parameter group. The relevant parameter input for the following discussion is `base_color`. 

To apply the shader to the terrain, return to the stage level. 

# On the material library, click the Auto-fill Materials button. The material is now added to the Material VOP and Material Path parameters.
# Turn on Assign to Geometry.
# For Geometry Path, enter the Solaris path to the heightfield. By default, this is `/sopimport1/height`, but if you've applied a custom path and name, you have to use it.
# Dive into the material's subnetwork again.

## Texture layers - Shader setup
Let's start with a base color to represent the terrain's bedrock. Add a MtlX Mix VOP and connect its `out` pin with the shader's `base_color` parameter. From the mix node's Signature dropdown menu, choose Color (Color). you can now see three black color definitions named Fg (foreground), Bg (background) and Mix (mask).

# Click the Bg color field and choose an orange color.
# For Fg, define a red color.

The heightfield turns orange, although it's the background color. The reason is the Mix color. Pure black means that the background color will be shown with 100% intensity. When you set Mix to pure white, the terrain turns red. Values (= shades of gray) create mixed colors. You can check this by clicking through the Color Editor's grey color fields. With each click, you can see how the terrain's appearance changes. The layers of the terrain take on the role as a mix map and control how the colors are blended.

# To get a layer's values put down a MtlX Geometry Property Value VOP.
# For the Geomprop parameter, enter `flow`. Heightfield layers are always of type float, so you don't have to change Signature.
# Connect the `out` output of the property node with the `mix` input of the mix node.

To finally see the result you need to render the viewport. In the upper left corner of the viewport you can see two dropdown menus. Open the first menu and choose Karma XPU for a fast preview. You should now get a terrain similar to the image below.

### Adding more layers

In a more complex terrain network you often write out a wide variety of layers, for example from a HeightField Mask by Feature SOP. The next example shows to combine the already existing `flow` layer with an `occlusion` layer to accentuate the terrain's ridges.

# Inside the shader, add another MtlX Mix VOP. The result of the first mix will now serve as the background for the occlusion mix. Connect the `out` pin of `mtlxmix1` to the `bg` input of the new mix node.
# Lay down a new MtlX Geometry Property Value VOP and connect it to the new mix node's `mix` input.
# On the new property node, set Geomprop to `occlusion`.
# Connect the `out` pin of the new mix node with the shader's `base_color` channel.

Here's how a terrain could look with two layers - here with an Environment Light LOP.

What you're doing here is to cascade and stack multiple maps and each MtlX Mix VOP gets the result of the previous mix plus a new map or color. If you also want to add maps for specularity, roughness and other properties, you have to combine those maps through layer mixes as well.

## Texture layers - Maps
The above description uses colors, but in most cases you want work with textures. Houdini's heightfields come with UVs, but in very steep areas you might observe stretching and distortion effects. Visible seams or repetitive patterns are also often an issue with large terrains.

It can therefore be better to use triplanar mapping. The MaterialX system provides a MtlX Triplanar Projection VOP. We also recommend our very own Karma Hexagonal Tiling Triplanar VOP. This nodes "scatters" maps over an area by creating a hexagonal pattern. The patches can have random scale and rotation to avoid seams and patterns.

The triplanar node expect texture maps and you can connect their `out` pins to the `fg` and `bg` inputs of the MtlX Mix VOP to replace the colors.

============================================================
# 来源: vexsnippets.txt
============================================================

## VEX scripts for heightfields
Customize terrains, masks, and layers through VEX.

This collection contains several useful VEX snippets as a starting point for more complex scripts. Most scripts let you create different types of masks, but you can also control the `height` layer. Before you start, please consider a couple of things.

* Most scripts are based on the Generating a height field from scratch guide that consists of two nodes: a HeightField SOP and a HeightField Noise SOP.

* To use the scripts you need a HeightField Wrangle SOP. Then copy Ctrl+C and paste Ctrl+V the chosen script to the node's VEXPression field.

* Most of the scripts, presented below, use custom parameters introduced through a `ch` statement, e.g. `chf("radius")`. To add custom parameters to the UI, press the  Create spare parameter... button.

* The mask scripts don't reset existing masks! If you want to empty the `mask` layer before you create a scripted mask, add a HeightField Layer Clear SOP before the wrangle. Then set the layer clear node's Layer 1 to `mask`.

* Scripted masks sometimes look jagged. Add a HeightField Mask Blur SOP after the wrangle to soften the mask's borders.

[TIP]
    The Removing scatter points page also contains various VEX scripts and techniques you might find interesting.

## VEX scripts for heightfields - Getting voxel values
The process of reading out a heightfield's voxel value is always the same. However, the type of data, returned by the function, depends on a layer's content. When you go over a `height` layer, fo example, you will get height values. If it's a `mask` layer, you'll get the intensity of the mask at each voxel, and so on.

However, `height` and `mask` are special cases, because they're build-in layers and evaluated automatically just by calling them as attributes `@height` and `@mask`. But you can also read out the values of this layers manually. The following function reads the `mask` layer from input `0`, and through all voxels.

    float mask_value = volumeindex(0, "mask", set(i@ix, i@iy, i@iz));

Here's a more generic form with `@P` instead of the grid's inidices.

    signature layer_value = volumeindex(int input, "layer_name", @P);

## VEX scripts for heightfields - Circle mask
Circles are certainly one of the most often required shapes for masking, e.g. if you want to create craters, cut out a patch, and whatnot. Fortunately, it only takes a few lines of VEX code to create such a mask.

    vector position = chv("position");
    vector offset = set(position.x, 0, position.z);
    
    if (length(v@P - offset) < chf("radius")) {
        @mask = 1;
    }

The first line reads the values from a custom `position` vector. This vector defines the circle's center. The `offset` vector uses only the X and Z components of `position`, because heightfields don't have a Y value. If a voxel lies within the circle with a given custom `radius`, it'll be added to the mask,

You can blur, invert, shrink or expand the result with appropriate nodes like any other mask.

## VEX scripts for heightfields - Ring mask
Instead of a circle, you can create a ring by defining a custom inner and outer radius.

    vector position = chv("position");
    vector offset = set(position.x, 0, position.z);
    float midpoint = length(v@P - offset);
    
    if (midpoint > chf("inner_radius") && midpoint < chf("outer_radius")) {
        @mask = 1;
    }

The code is very similar to the script from Circle mask. The main difference is that you compare against two values here, not just a single Radius. And, instead of writing `length(v@P - offset)` twice inside the if-clause, the term is now a separate `midpoint` variable.

## VEX scripts for heightfields - Oval mask
Instead of a circle you can also create an oval mask. You need two parameters to define the oval's X and Y dimensions. An offset defines the distance from the terrain's default origin at `[0,0]`, and you can also rotate the shape.

    float a = chf("x_dimension");
    float b = chf("z_dimension");
    vector offset = chv("offset");
    float rotation = radians(chf("rotation")); // Degree -> radians
    
    // Position of the current voxel relative to its offset
    vector pos = set(@P.x - offset.x, @P.z - offset.z);
    
    // Rotate the ellipse
    vector rotated_pos;
    rotated_pos.x = cos(rotation) * pos.x - sin(rotation) * pos.y;
    rotated_pos.y = sin(rotation) * pos.x + cos(rotation) * pos.y;
    
    // Test ellipse equation with transformed coordinates
    float ellipse_equation = pow(rotated_pos.x / a, 2) + pow(rotated_pos.y / b, 2);
    
    if (ellipse_equation <= 1.0) {
        @mask = 1.0;
    }

The first four lines define the parameters for customizing the ellipse.

Then, the script calculates a position vector with the offset. This vector determines the oval's center. The `rotated_pos` vector stores the rotated position values. The `ellipse_equation` defines the inner area of the ellipse and if this value is smaller than or equal to 1.0, a voxel is inside the ellipse and part of the mask.

## VEX scripts for heightfields - Height mask
You can achieve this effect with the HeightField Mask by Feature SOP, but here's a short and handy script for masking voxels inside a lower and an upper limit. You can, for example, add this snippet to other scripts or write your masking tool with custom parameters.

    if (@height >= chf("lower_limit") && @height <= chf("upper_limit") ) {
        @mask = 1;
    }

If the terrain's height is between the values of the custom channel for `lower_limit` and `upper_limit`, the voxel will be added to the mask.

## VEX scripts for heightfields - Gradient mask
Some of Houdini's heightfield nodes don't provide gradient masks, so they could be a good addition for your arsenal of tools.

    vector gradient = volumegradient(0, "height", v@P);
    
    if (fit01(length(gradient), 0, 1) > chf("threshold")) {
        @mask = 1;
    }

The first line reads the `volumegradient` from the `height` layer at the wrangle's first (`0`) input, using the voxel `@P` positions.

The `length` of the `gradient`vector from line 1 is remapped to a `0, 1` range to make it easier to compare. If a voxel's `gradient` value is greater than a custom `threshold`, the voxel will be part of `@mask`.

## VEX scripts for heightfields - Clipping
This short script caps the heightfield above a custom `threshold`. If `height` is greater than or equal to the `threshold` value, the maximum height will be the adjusted value.

    float threshold = chf("threshold");
    
    if (@height >= threshold) {
        @height = threshold;
    }

## VEX scripts for heightfields - 3D Worley noise mask
Houdini's VEX language provides a wide range of different noise types. You can use the different noise types to define masks, but also to create terrains. You can find an example for the latter case directly below.

    // Variables
    vector frequency = chv("frequency");
    float amplitude = chf("amplitude");
    vector offset = chv("offset");
    int seed;
    float f1, f2, f3, f4;
    
    // Noise values
    wnoise(v@P * frequency + offset, seed, f1, f2, f3, f4);
    float noise_value = f1 * amplitude;
    
    // Create mask
    if (noise_value > chf("threshold")) {
        @mask = 1;
    }

## VEX scripts for heightfields - Applying masks to snoise
In this script, the terrain's `height` is calculated through a snoise function. An already existing `mask` layer attenuates the `height` values and the noise's element size.

You can, for example, add an upstream HeightField Mask Noise SOP to create an initial mask.

    float amplitude = chf("amplitude");
    float element_size = chf("element_size") * @mask;
    int turbulence = chi("turbulence");
    int period_x = chi("period_X");
    int period_y = chi("period_Y");
    int period_z = chi("period_Z");
    float attenuation = chf("attenuation");
    
    @height = snoise(@P * element_size, period_x ,period_y, period_z, turbulence, 0, attenuation) * amplitude * @mask;

The lines with leading `float` and `int` statements create the custom parameters for configuring the `snoise` function below.

The script calculates the terrain's `height` values with a fully parametric `snoise` function. The noise is then multiplied with `amplitude * @mask` at the given position `@P`.

## VEX scripts for heightfields - Ramp to heightfield
This script converts a ramp into a heightfield. You can draw a curve through a ramp and the terrain will follow the curve's shape. You can also define a custom `height_factor` to scale the terrain.

    vector bounding_box = relbbox(0, @P);
    float elevation = chramp("remap", bounding_box.z);
    
    @height += elevation * chf("height_factor");

The script creates a bounding box around the heightfield and samples the positions `@P` inside. The Z position is added to custom ramp to calculate the terrain's elevation.

The final `@height` is summed up from the product of `elevation` and a custom `height_factor`.

## VEX scripts for heightfields - Curve follows terrain
You can transform a curve so that it follow a terrain. The script runs inside a HeightField Wrangle SOP. In fact, this method is pretty much what the HeightField Project SOP, when you project geometry onto a terrain.

# Inside the Geometry OBJ with the terrain, add a Curve SOP. You can also use one of the predefined tools for polygons, Bezier curves or splines. 
# Hover the mouse cursor over the viewport and press Enter to turn on the node's drawing mode.
# Also on the viewport, press 1 to change perspective to top and draw the curve in the XZ plane.
# With polygons, LMB-click to draw the curve points. With Bezier curves or splines, LMB-click and drag the mouse to add curvature.
# Once you're happy with the curve, press ESC to leave the drawing mode.
# Lay down a Resample SOP and connect its input with the output of the curve. This node increases the number of curve points to get a sufficient amount of sampling points. The default Length should create enough resolution.
# Connect the resample node's output to the wrangle's first input and the heightfield to the second input. The connection order is important to get correct results.

    vector hit_pos, hit_uv;
    int prim = intersect(1, @P, {0, -1000, 0}, hit_pos, hit_uv);
    
    if (prim >= 0) {
       @P = hit_pos; 
       @N = prim(1, "N", prim)
    }

The centerpiece of the script is the `intersect` function. This function sends out a ray from the curve towards the heightfield at input `1`. Direction and maximum distance to search for intersections are defined in `{0, -1000}`. 

If the ray hits the terrain, the `pos` vector will contain the position of the intersection. With a direction of `0`, the `pos` vector's Y component equals the terrain's height.

The last line transfers the `pos` vector to a curve point's position `@P`. The `uv` vector is not used here, but it's a mandatory argument of the `intersect` function.

## VEX scripts for heightfields - Combining masks
You can combine various masks and apply a ramp to modify the result and create something entirely new.

# Add a HeightField Wrangle SOP somewhere in your network, but downstream of the masks/layers you want to combine.
# Use Ctrl+C and Ctrl+V to copy and paste the code below to the wrangle's VEXpression field.

    This example code below uses `@slope` and `@occlusion` layers. You must replace the layers with the actual names from your network. If you want to add more layers, just append them to the formula through multiplication: `@layer_1 * @layer_2 * ... * @layer_n`

# Click the  Create spare parameter... button to create the ramp.

    @mask = @slope * @occlusion; // Use your actual layer names here

============================================================
# 来源: workflows.txt
============================================================

## Various features
Convert, export and spice up your terrains.

Houdini's heightfields provide a wide range of nodes that help you to refine, change, convert, and manipulate terrains. This chapter is a loose collection of nodes that don't require a complete page.

[NOTE]
    The basic setup for the examples on this page always consists of a HeightField SOP and a HeightField Noise SOP. You can proceed with the nodes' default settings. 

    Here, the HeightField SOP's Grid Space was decreased to `1` to reveal more structures, but you can also leave the standard value of `2` to speed up the creation process.

## Various features - Shelf tools
Houdini's shelf is a convenient way to access preconfigured tools that serve as examples or starting points for your own experiments. For heightfields there are also several shelves available, but you have to turn on some of them manually.

The Terrain FX shelf is visible by default. This shelf contains several examples to get you started. You can, for example, create a solitary mountain, a moonscape with craters, sand dunes and many more.

To show the invisible shelf tools, go to the shelf. There you can see several tabs like Lights and Cameras, Collision, etc. - and a  button. 

# Click the button to open a dropdown menu and choose Shelves.
# Turn on the shelves you want to hook to the UI, e.g. Terrain Tools.

The terrain shelf collections contain the entire range of heightfield nodes from the tab menu for fast access.

table width="100%">>
    tr>>
        td>>[Largeicon:SOP/heightfield_slump]
        td>>[Largeicon:SOP/heightfield_deform]
        td>>[Largeicon:SOP/heightfield_terrace]
        td>>[Largeicon:SOP/heightfield_scatter]
        td>>[Largeicon:SOP/heightfield_file]
        td>>[Largeicon:SOP/heightfield_isolatelayer]
        td>>[Largeicon:SOP/heightfield_crop]
        td>>[Largeicon:SOP/heightfield_cutoutbyobject]

## Various features - HeightField conversion
Heightfields are 2-dimensional volumetric grids, not actual geometry. This circumstance makes it sometimes difficult or even impossible to perform certain operations. The flip side of the coin is that real geometry, made of points and polygons, requires much more resources.

One of the biggest advantages with geometry is that you can create and add all kinds of attributes. Attributes are Houdini's DNA, and you can use them to control any aspect of a model, a texture or a render. You also have a third dimension that lets you manipulate points, polygons, and normals. Masks and layers are also transferred to the polygon representation of your heightfields as point attributes.

A default heightfield with noise allocates 4 MB, while the same terrain weighs in at 183 MB with the standard conversion settings. There are methods to reduce the number of polygons, but in general, the difference is huge.

The centerpiece of the entire conversion process is the Convert HeightField SOP.

### Conversion settings

The Convert HeightField SOP provides a Convert to dropdown menu with three options.

    * Polygon creates regular polygons. The Connectivity menu lets you choose which type of polygons you want to create, e.g. triangles or quadrilaterals. Triangles, however, require more resources and our standard heightfield with triangles allocates 260 MB.
    * Polygon Soup is an economic and lightweight format where all polygons are packed and not accessible anymore. A standard heightfield with noise as a polygon soup requires approximately 96 MB.
    * VDB converts the heightfield into a volume. After the conversion to OpenVDB you have access to Houdini's manifold VDB tools. This option will also always extrude the heightfield to create a closed object. If you want a surface-like object, turn off Flatten Base. A basic VDB heightfield with noise requires 146 MB.

With Density you control the quality of the converted object. Higher values create more polygons/voxel, but also "heavier" objects. And you have to consider the HeightField SOP's resolution (Grid Spacing or Grid Samples). You won't get more detail with an increased Density with a small Grid Spacing value.

## Various features - Remapping
The HeightField Remap SOP lets you change a layer's values in a separate process. You're not limited to a terrain's `height` layer, and the method also works with `mask` values or any other layer. However, the most common application is to remap the `height` layer. This way it's possible to create completely different landscapes interactively without having to change the initial values. You can, for example, apply a sea level and turn the terrain into a rocky coast. Or you make a river run through a mountain range as in the example below.

The idea is to define a new minimum and maximum value and then use a ramp to alter all values between these two heights. Imagine you've created a terrain you're happy with, but the terrain's profile doesn't meet you expectations. You want more peaks, stepper rock faces and wider valleys. Instead of looking for adequate noise settings, you can use a HeightField Remap SOP and adjust the height values, e.g. with the help of a custom ramp.

### Riverbed

In this example you'll add a riverbed to a mountainous terrain. The river follows the landscape's natural conditions and thus has wider and narrower parts.

# Add a HeightField Remap SOP to the basic setup and connect its first input with the output of the upstream HeightField Noise SOP.
# Turn the remap node's blue Display/Render flag.
# Click the Compute Range button. This determines the terrain's lowest and the highest points and writes them to Input Min and Input Max

You can also see the input values on Output Min and Output Max. This pair of values keeps the original terrain because input equals output. Change the input values to, lets say, `-150` and `100`. You will see that lower parts are shifted along the negative Y axis and the terrain becomes deeper. The higher parts are also slightly lowered by approximately 12 meters.

### Remapping ramp

# The Remap curve provides information about the terrain's height distribution. The outer left point indicates the lowest value and on the right you have the highest value. When you drag the yellow point on the left upwards, you will notice that the terrains becomes totally flat: now minimum and maximum values are equal.
# Click on the curve to create another control point.
# The parameters below now show Point No. set to `3`. Change Position to `0.4` and Values to `0.2`.
# Create another point. The new point's Position is `0.5` and Value is also `0.2`.

The Position values can range from `0` to `1` and they're related to the heightfield's dimensions. In this example, the terrain's width is 1000 meters. This means that ramp Position values of `0.4` and `0.5` indicate 400 and 500 meters.
For a heightfield that has a width of, let's say, 1563 meters, the two resulting values are `1563 m * 0.4 = 977.2 m` and `1563 m * 0.5 = 781.5 m`.

Now you can see a flat area between the mountains. This is the river bed. The area is flat, because here, all height values are equal.

## Various features - HeightField Crop
The HeightField Crop SOP lets you create rectangular cutouts from an existing heightfield. You can also connect any other geometry, but the node will always create a bounding box from this object to define the cropping area.

Without a supporting object, you can define Size and Center of the cropping area and its Orientation.

If you want to precisely expand or shrink the cutout, use Voxel Padding. This parameter accepts positive and negative values.

## Various features - HeightField Cutout by Geometry
There are situations, where you don't need an entire terrain, but only a section. The difference to the HeightField Crop SOP is that you can use any geometry to define the area you want to keep or remove. You can rotate, scale, and transform the cutout object in any possible to way to create really fancy shapes. Even animated, deforming, and packed geometry is supported.

The Heightfield Cutout by Geometry SOP has two inputs. The

* first input connects with the heightfield
* second input expects the geometry you want to use as a cutout.

You can also choose from various Combine modes to create holes or sections, and invert the cutout.

A convenient workflow is to outline the cutout region with a Curve SOP. Set the curve's Primitive Type to Polygon and move it below the heightfield, e.g. with a Transform SOP. Then, connect an Extrude Volume SOP and increase its Depth parameter until the newly created volume encloses the entire terrain. Then you can connect the volume to the HeightField Cutout by Geometry SOP's second input. This way you get an irregular shape you can refine at any time to optimize your terrain.

## Various features - HeightField Output
If you want to export a heightfield's layers, you can save those as displacement maps through a HeightField Output SOP. There are couple of things to consider.

[NOTE]
    This short guide explains only the most fundamental settings. For a detailed breakdown of file formats, export possibilities and color depth options, please read the node help.

The first step is to define a Filename.

The Output Type dropdown menu lets you choose whether you want to write a Packed Raster or a Deep Raster.

With the first option, each layer is written into RGBA color channels. Use this option for image formats like PNG or JPG. The number of layers you can export separately is therefore limited to four. The second option writes each layer as a separate deep raster plane. In this case you need a file format that's capable of creating such a data structure, e.g. PIC or EXR.

To catch all detail from your terrain, Type should be at least 16 b Floating Point, for even better results leave the default 32 b Floating Point option. The latter one corresponds with Houdini's internal precision for layers. 16 bit and 32 bit also require an appropriate file format like PIC or EXR.

You can also define a custom resolution for your maps. Otherwise the image uses the heightfield's volume resolution (by default 1000 x 1000). This is important with cropped heightfields or cutouts. In this case it's better to use a custom resolution, because the maps might become very small as the remaining terrain has only a fracture of the original size.

In the Output Layers section you enter the layers you want to export.

* Packed Raster. You can add one layer per channel. All available layers are listed in the dropdown menus next to a color channel.
* Deep Raster. You can specify space-separated lists of layers to save as named image planes. When you enter the layers to (0,1) Layers, all values will be remapped to 0 to 1 range. If you want to use (-1,1) Layers, choose a file format that supports negative values.

You can also subdivide large maps into several separate tiles. Choose, whether you want to tile by size or a fixed number of tiles with Tile Method. Please also consider changing File Naming if you don't want to use the default UDIM style.

Once you've made your settings, click Save to Disk.
