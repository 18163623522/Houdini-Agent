= Surfacing =

:fig: [Image:/images/mpm/pumpkin.jpg]
    """Sledge Hammer by MaX3Dd. Pumpkin Scan by Arkify 3D."""

[MPM Surface SOP|Node:sop/mpmsurface] creates a surface based on a MPM simulation. It can output VDBs as well as polygon meshes. This node comes with many functionalities to streamline the process of turning your MPM simulation into renderable geometry. 

You can choose your __Output Type__ as well as the __Method__. The __Neural Point Surface__ method uses the [Neural Point Surface|Node:sop/neuralpointsurface] node to generate the `surface` grid using a pre-trained neural network. This is the newer and more experimental approach, but gives good results out of the box if you have a high-end graphics card. 

The __VDB from Particles__ method uses a combination of VDB morphological operations to generate the `surface` grid. This is the more robust and traditional approach, however you will most likely need to tweak the parameters to get the desired look. This method is generally preferred if you have a lower end or mid-end GPU, or when you are dealing with very large simulations involving millions of particles.

Another useful feature is the ability to partition the point cloud so that large point clouds can be processed on OpenCL devices with limited amount of memory. However, this option should only be turned on if your OpenCL device (GPU) is running out of memory while cooking the node, as it may degrade performance and should be used if necessary. This option is only available when using the __Neural Point Surface__ method.

:col: 
    [Image:/images/mpm/partition_no.jpg]
    
    """__Enable Partitioning__ off"""

:col:
    [Image:/images/mpm/partition_yes.jpg]
    
    """__Enable Partitioning__ on, with three partitions created"""
    
There are also some unique inputs on this node to be aware of. The second input takes the output of the [MPM Surface|Node:sop/mpmsurface], which is useful to split the SDF creation from the polygon mesh creation in two separate steps. For example, if you need a collider representation of the MPM particles for secondary simulation, this prevents you from having to recompute everything from scratch since you will already have a representation of the surface as a volume and the velocity field. To save on computation, you can just take the output of one MPM Surface node and plug it into the second input of another MPM Surface node. It allows you to cache the SDF representation as a collider for another simulation, and then cache the version you need for rendering.

The third input takes the renderable geometry used by the [MPM Source|Node:sop/mpmsource]. This is useful when you want to transfer UVs. You can provide the source model at its rest position, and when connected to the third input, you can transfer UVs per island.

The fourth input uses a VDB `surface` used as a mask to prune polygons that would not be visible at render time. In the landslide example, you could use the slope as a mask to reduce the amount of polygons generated by the MPM Surface.

See [Neural point surfacing|/mpm/nps] for more information.